<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paper Note - ICDE | Tong Yu</title>
    <link>/categories/paper-note-icde/</link>
      <atom:link href="/categories/paper-note-icde/index.xml" rel="self" type="application/rss+xml" />
    <description>Paper Note - ICDE</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sat, 22 Feb 2020 15:10:51 +0800</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Paper Note - ICDE</title>
      <link>/categories/paper-note-icde/</link>
    </image>
    
    <item>
      <title>Paper Note - 2020/2/22</title>
      <link>/post/2020-2-22-1/</link>
      <pubDate>Sat, 22 Feb 2020 15:10:51 +0800</pubDate>
      <guid>/post/2020-2-22-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;Vehicle shortage is not uncommon in popular ridesharing platforms. The shortage of vehicle disables the platform from dispatching all orders immediately, and some requesters would have to wait if their orders are pended. In practice, requesters who are anxious and not cost-sensitive, may wish to pay more to get dispatch priority.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;An auction-based order dispatch and pricing mechanism are proposed.&lt;/strong&gt; In this auction mechanism, the requesters(riders) act as buyers. They submit origins &amp;amp; destinations and bids to the platform server. With bids, the requesters claim the amount of money they would like to pay to take the service. The platform acts as the auctioneer, selling the shard-rides to requesters. With respect to their bids, the platform computes a dispatch, and decides the final payments of dispatched requesters.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;The proposed algorithms manage to maximize the overall utility of the auction, which is comprised of requesters’ utility, drivers’ utility, and platform’s utility.&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-symbols&#34;&gt;3.1. Symbols&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/symbol_hu3dd0bc9f55fadd58d3e60c6aafe9c868_104313_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/symbol_hu3dd0bc9f55fadd58d3e60c6aafe9c868_104313_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;776&#34; height=&#34;465&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;32-entity-models&#34;&gt;3.2. Entity Models&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;We adopt the round-based order dispatch model for our mechanism. In each round, the platform server operates on a set of pended orders and online vehicles to optimize some objectives.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wasted time&lt;/strong&gt; :  the wasted time of a dispatched requester $r_j$ is $wt_j + dt_j$
&lt;ul&gt;
&lt;li&gt;$wt_j$ : his/her waiting time during pick-up&lt;/li&gt;
&lt;li&gt;$dt_j$ : his/her detour time during delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Requester&lt;/strong&gt; : a requester rj is represented by a tuple $&amp;lt;s_j,e_j,\theta_j,val_j,bid_j&amp;gt;$
&lt;ul&gt;
&lt;li&gt;$s_j$ and $e_j$ : starting and ending geographical locations of its trip&lt;/li&gt;
&lt;li&gt;$val_j$ and $bid_j$ : $r_j$’s valuation of the service and bid to the platform respectively&lt;/li&gt;
&lt;li&gt;$\theta_j$ : his/her maximum allowed amount of wasted time during pick-up and delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vehicle&lt;/strong&gt; : $&amp;lt;l_i,pl_i&amp;gt;$
&lt;ul&gt;
&lt;li&gt;$l_i$ : its current location&lt;/li&gt;
&lt;li&gt;$pl_i$ : its travel plan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Validity of travel plans&lt;/strong&gt; : precedence constraint, capacity constraint, time constraint&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Payments to vehicles&lt;/strong&gt; : We assume platform’s payment to a vehicle is proportional to its travel distance after it picks up the first rider. Let $rev_i$ denote the revenue of $v_i$ .
&lt;ul&gt;
&lt;li&gt;$rev_i = \beta_d * D_i$&lt;/li&gt;
&lt;li&gt;$\beta_d$ : the payment to vehicle per unit travel distance&lt;/li&gt;
&lt;li&gt;$D_i$ : the travel distance of $v_i$ during delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-problem-formulation&#34;&gt;3.3. Problem Formulation&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Requester’s utility&lt;/strong&gt; : $u_j = (val_j - pay_j) \cdot x_j$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x_j$ equals 1 if the order of $r_j$ is dispatched, or 0 otherwise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Platform’s utility&lt;/strong&gt; : $U_{plf} = \sum_{r_j \in \hat{R}}{pay_j} - \sum_{v_i}{rev_i}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\hat{R}$ : the set of dispatched requesters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Driver’s utility&lt;/strong&gt; : $u_i = rev_i -\alpha_d D_i = (\beta_d - \alpha_d)D_i$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha_d$ : measures the labor &amp;amp; fuel cost per unit travel distance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Overall utility&lt;/strong&gt; : The utility of truthful auction in ridesharing is defined as the sum of requesters’ utilities, platform’s utility, and drivers’ utilities, i.e..





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/utility_hud7c2f055f314aea9d813532436946f75_45896_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/utility_hud7c2f055f314aea9d813532436946f75_45896_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;881&#34; height=&#34;325&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$bid_j = val_j$ because of auction truthfulness&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Order dispatch problem&lt;/strong&gt; : Given inputs of requester set $R$ and vehicle set $V$ , the order dispatch problem in auction-based ridesharing is to dispatch requesters $r_j \in R$ to vehicles $v_i \in V$ such that the overall utility is maximized.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Order pricing problem&lt;/strong&gt; : The order pricing problem is to determine the payment for each dispatched requester such that the auction mechanism &lt;strong&gt;satisfies the following properties&lt;/strong&gt;: truthfulness, individual rationality, profitability and computational efficiency.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Truthfulness&lt;/strong&gt; : An auction is truthful if the best strategy of any requester is to bid his/her valuation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Individual rationality&lt;/strong&gt; : An auction is individually rational if the utility of any requester is non-negative.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Profitability&lt;/strong&gt; : An auction is profitable if the utility of the platform is non-negative.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Computational efficiency&lt;/strong&gt; : An auction is computationally efficient if the process of winner selection and payment computation can finish within polynomial time.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The order dispatch problem is NP-hard.&lt;/p&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-the-greedy-approach&#34;&gt;4.1. The Greedy Approach&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Greedy-based order dispatch proceeds in two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Initialization&lt;/strong&gt; : It traverses all requester-vehicle pairs to find the valid dispatches, and calculates the corresponding utilities. Valid dispatch means that $pl_i$ remains valid after accommodating $r_j$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One-by-one dispatch&lt;/strong&gt; : It keeps dispatching $(r_j∗, v_i∗)$ which brings the maximum utility among the remaining valid dispatches. The utility $u_{i,j}$ is calculated as $u_{i,j}=bid_j - \alpha_d * \Delta D_i(r_j)$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/algorithm_1_hu12ffe048d93267b1b9c0f253235a764d_135273_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/algorithm_1_hu12ffe048d93267b1b9c0f253235a764d_135273_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;735&#34; height=&#34;682&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Order pricing for greedy dispatch





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/algorithm_2_hu03ef167f1e1d95b1259d71af5defba46_120078_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/algorithm_2_hu03ef167f1e1d95b1259d71af5defba46_120078_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;770&#34; height=&#34;557&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-the-ranking-approach&#34;&gt;4.2. The Ranking Approach&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Order Dispatch
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pack generation&lt;/strong&gt; : For each $r_j$ , we find its nearest vehicle, $v_{r_j}$ . Then, for each $r_j$ , we find the optimal pack which contains $r_j$ and has at most $\bar{c}$ requesters, such that dispatching this pack to one of their nearest vehicles yields the maximum utility.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pack dispatch&lt;/strong&gt; : The packs are ranked in descending order of their utilities. Then, they are dispatched in the order of their rankings. The algorithm firstly retrieves the pack with the highest ranking, $pack_{j∗}$ among the remaining packs. Then, it dispatches $pack_{j∗}$ to its vehicle $v_{pack_{j∗}}$ . Finally, it removes the remaining packs whose requesters or vehicles are occupied by $pack_{j∗}$ . The pack dispatch process terminates when $Rank$ becomes empty.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/algorithm_3_hud73abff544603dddf1a5a9f6c8b0501c_139310_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/algorithm_3_hud73abff544603dddf1a5a9f6c8b0501c_139310_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;783&#34; height=&#34;639&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;Data set : Beijing, Didi.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/17</title>
      <link>/post/2020-2-17-1/</link>
      <pubDate>Mon, 17 Feb 2020 13:18:21 +0800</pubDate>
      <guid>/post/2020-2-17-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Ridesharing refers to a transportation scenario where travellers with similar itineraries and time schedules share a vehicle for a trip and split the travel costs such as fuel, tolls, and parking fees.&lt;/li&gt;
&lt;li&gt;When travellers need to travel to some destination, they often &lt;strong&gt;have several options&lt;/strong&gt; to choose among. In such a setting, the cost and travel time of an option are important decision criteria.&lt;/li&gt;
&lt;li&gt;In the paper, it&amp;rsquo;s assumed that the destination of a vehicle is not limited and that it can accommodate any number of rider groups during a trip as long as it satisfies a capacity constraint.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;Given a set of vehicles $C$ in the road network $G$ at a specific time and a real-time trip request set $S_{R}$ , dynamic ridesharing finds, for each trip request $R \in S_{R}$ , &lt;u&gt;all qualified and non-dominated results &lt;/u&gt; $&amp;lt;c, time, price&amp;gt;$ .&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-symbols&#34;&gt;3.1. Symbols&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-17-1/symbol_hu0609361d40184b3cb86646c0ec4482bd_209770_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-17-1/symbol_hu0609361d40184b3cb86646c0ec4482bd_209770_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;744&#34; height=&#34;671&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;32-definition&#34;&gt;3.2. Definition&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Ridesharing Request&lt;/strong&gt; : A ridesharing request $R=&amp;lt;s,d,n,w,\epsilon&amp;gt;$ on a road network $G$ is defined by a start location $s$ , a destination location $d$ ,  a number $n$ of riders, a maximal waiting time $w$ , and a service constraint $\epsilon$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vehicle Trip Schedule&lt;/strong&gt; : Each trip schedule $tr=&amp;lt;o_{1},o_{2},\cdots,o_{k}&amp;gt;$ contains a sequence of locations, where $o_{1}$ is the current location $c.l$ of vehicle $c$ , and $o_{i}$ $(2 \leq i \leq k)$ denotes the start location or destination of an unfinished ridesharing request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Schedule Constraint&lt;/strong&gt; : A valid trip schedule needs to satisfy the four following conditions
&lt;ol&gt;
&lt;li&gt;Capacity constraint&lt;/li&gt;
&lt;li&gt;Point order&lt;/li&gt;
&lt;li&gt;Waiting time constraint&lt;/li&gt;
&lt;li&gt;Service constraint&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Price Model&lt;/strong&gt; :  For a ridesharing request $R=&amp;lt;s,d,w,n,\epsilon&amp;gt;$ , assume that $tr_{i}$ is the current trip schedule of a vehicle $c$ and $tr_{i}$ is the new trip schedule after inserting $R$ into $tr_{i}$ , the price is computed  as $f_{n} \times (dist_{tr_{j}}-dist_{tr_{i}}+dist(s,d))$ , where $f_n$ is price ratio that depends on the number $n$ of riders.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-index-structures&#34;&gt;4.1. Index Structures&lt;/h3&gt;
&lt;h4 id=&#34;411-road-network-indexing&#34;&gt;4.1.1. Road Network Indexing&lt;/h4&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-17-1/method_1_hub8b1d46d20ff19fb3758aa4ae0691b19_111644_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-17-1/method_1_hub8b1d46d20ff19fb3758aa4ae0691b19_111644_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1053&#34; height=&#34;372&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;If an edge $e=(u,v)$ belongs to more than one grid cell, we call $u$ and $v$ &lt;strong&gt;border vertices&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;To estimate the shortest path distance precisely, we maintain a matrix $M$ that stores the lower bound distance for every grid cell pair.&lt;/li&gt;
&lt;li&gt;Each grid cell maintains five lists :
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;border vertex list&lt;/strong&gt; : border vertices belonging to the grid cell&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vertex list&lt;/strong&gt; : vertices belonging to the grid cell, as each vertex $v$ is associated with its &lt;u&gt;shortest path distances&lt;/u&gt; to the border vertices ($BV$) of the grid cell ($\{ &amp;lt; u,dist(v,u) &amp;gt; | u \in BV \}$) and is also associated with $\min \{ dist(v,u)  | u \in BV \} $ (denoted as $v.min$ )&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;grid cell list&lt;/strong&gt; : other grid cells sorted in ascending order of the travel time from these grid cells to the grid cell.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;empty vehicle list&lt;/strong&gt; :  vehicles with empty ridesharing requests in $g_{i}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;non-empty vehicle list&lt;/strong&gt; : vehicles $c_j$ with a non-empty set of ridesharing requests, i.e., vehicles $c_j$ are currently located in $g_j$ or are scheduled to enter $g_{i}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lower Bound Distance&lt;/strong&gt; : Given a vertex $u$ in a grid cell $g_i$ and a vertex $v$ in a grid cell $g_j$ , if $g_i \neq g_j$ , then the lower bound distance $ldist(u, v) = D_{ij} + u.min + v.min$ ; if $gi = gj$ , then $ldist(u, v) = 0$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upper Bound Distance&lt;/strong&gt; : if $g_i \neq g_j$ , then the upper bound distance $udist(u, v) = D_{ij} + dist(u, x_{ij}) + dist(v, y_{ij})$ ; if $g_i = g_j$ , then $udist(u, v) = \min \{dist(u, b) + dist(v, b) | b \in BV \}$ .&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;412-index-of-vehicle-trip-schedules&#34;&gt;4.1.2. Index of Vehicle Trip Schedules&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Representation of each vehicle $c$ :
&lt;ol&gt;
&lt;li&gt;the unique identifier $c.ID$ of the vehicle&lt;/li&gt;
&lt;li&gt;the current location $c.l$ of the vehicle&lt;/li&gt;
&lt;li&gt;the set $c.S$ of unfinished ridesharing requests assigned to it, sorted in ascending order of their timestamps&lt;/li&gt;
&lt;li&gt;the set $c.S_{tr}$ of all valid vehicle trip schedules&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The set $c.S_{tr}$ of all valid vehicle trip schedules can be managed by a 
&lt;a href=&#34;https://tong-yu-pluto.github.io/post/2020-2-7-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kinetic tree&lt;/a&gt;
. &lt;u&gt;Three variables are added&lt;/u&gt; to each node $o_x$ of the kinetic tree :
&lt;ol&gt;
&lt;li&gt;a current vehicle’s capacity&lt;/li&gt;
&lt;li&gt;the minimal detour distance allowed&lt;/li&gt;
&lt;li&gt;the trip distance disttr from $c$’s current location to $o_x$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-17-1/method_2_hu33ad4396c989b445384c3081596e05ce_100835_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-17-1/method_2_hu33ad4396c989b445384c3081596e05ce_100835_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;865&#34; height=&#34;478&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The following global information of each grid cell $g_j$ is maintained to facilitate the pruning of a whole grid cell :
&lt;ol&gt;
&lt;li&gt;the maximum capacity : $\max \{ o_x.capacity | &amp;lt;o_x, o_y&amp;gt; \in  g_j \}$&lt;/li&gt;
&lt;li&gt;the maximal detour allowed : $\max \{ o_x.detour | &amp;lt;o_x, o_y&amp;gt; \in  g_j \}$&lt;/li&gt;
&lt;li&gt;the minimal trip distance : $dist_{tr}=\min \{ o_x.dist_{tr} | &amp;lt;o_x, o_y&amp;gt; \in  g_j \}$&lt;/li&gt;
&lt;li&gt;the maximal shortest path distance : $dist=\max \{ dist(o_x,o_y) | &amp;lt;o_x,o_y&amp;gt; \in g_j \}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-pruning-heuristics&#34;&gt;4.2. Pruning Heuristics&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : Based on the designed road network and vehicle indexes, we use the lower and upper bound distances instead of the actual shortest path distances to estimate pick-up time and price for filtering.&lt;/p&gt;
&lt;h4 id=&#34;421-pruning-empty-vehicles&#34;&gt;4.2.1. Pruning Empty Vehicles&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Given a current valid result $r_i$, we try to derive :
&lt;ol&gt;
&lt;li&gt;the pruning conditions implying that the estimated result $r_j$ (i.e., the lower bound values) returned by $c_j$ is dominated by $r_i$&lt;/li&gt;
&lt;li&gt;the pruning conditions implying that $r_j$ (i.e., the upper bound values) returned by $c_j$ dominates $r_i$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Based on the main idea, we can filter out invalid vehicles and grids.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;422-pruning-non-empty-vehicles&#34;&gt;4.2.2. Pruning Non-Empty Vehicles&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Pruning for inserting start location $s$ .&lt;/li&gt;
&lt;li&gt;Pruning for inserting destination location $d$ .&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-ridesharing-matching-algorithms&#34;&gt;4.3. Ridesharing Matching Algorithms&lt;/h3&gt;
&lt;p&gt;refer to 
&lt;a href=&#34;https://tong-yu-pluto.github.io/post/2020-2-4-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tshare&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;experiments on effect of&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the Number of Verified Grid Cells&lt;/li&gt;
&lt;li&gt;Waiting Time&lt;/li&gt;
&lt;li&gt;Service Constraint&lt;/li&gt;
&lt;li&gt;Capacity of Vehicle&lt;/li&gt;
&lt;li&gt;Number of Vehicles&lt;/li&gt;
&lt;li&gt;Grid Cell Size&lt;/li&gt;
&lt;li&gt;the Number of Requests&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/12</title>
      <link>/post/2020-2-12-1/</link>
      <pubDate>Wed, 12 Feb 2020 18:48:20 +0800</pubDate>
      <guid>/post/2020-2-12-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;Dynamic peer-to-peer ride sharing.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper proposes&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a hierarchical discretization of the geographical region using grids, landmarks and clusters with theoretical guarantees&lt;/li&gt;
&lt;li&gt;an efficient in-memory indexing of rides for maintaining spatio-temporal validity within a specified error tolerance&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-system-overview&#34;&gt;3. System Overview&lt;/h2&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/overview_hub884fbe196ff49b837e613841b2ee2a5_46173_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/overview_hub884fbe196ff49b837e613841b2ee2a5_46173_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;793&#34; height=&#34;474&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;XAR requires pre-processing of the geographical region where the system will be used.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The map-processor module in the pre-processing unit uses geographic information of the city from OpenStreetMap(OSM) to create grids and extract landmarks.&lt;/li&gt;
&lt;li&gt;Further, these landmarks are grouped together into clusters by the clustering module, using route information from OpenTripPlanner(OTP).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;XAR run-time unit kicks in when the system is actually deployed.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This unit provides functionalities like creating a ride offer in the system, finding matching rides for a request, booking seats in a matched ride and tracking rides in progress in real-time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-hierarchical-three-tiered-region-discretization&#34;&gt;4.1. Hierarchical Three-tiered Region Discretization&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_1_hu28a9df1509d2f0dd946215cba8436c21_13989_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_1_hu28a9df1509d2f0dd946215cba8436c21_13989_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;257&#34; height=&#34;301&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;A &lt;strong&gt;grid&lt;/strong&gt; is defined as a bounded square geographical region.
&lt;ul&gt;
&lt;li&gt;Any location is numerically mapped to a unique (implicit) grid, given its latitude and longitude.&lt;/li&gt;
&lt;li&gt;We identify a grid by its centroid, and henceforth wherever we refer to distances from a grid, these are measured with respect to the centroid of the grid.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;landmark&lt;/strong&gt; is a point of interest in a geographical region, such as a bus stop, a mall or an important building, such that it is sufficiently far (at least a pre-specified $f$ distance away) from any other landmark.
&lt;ul&gt;
&lt;li&gt;Each landmark is associated with a set of grids, and each grid is associated with a unique landmark, that minimizes the maximum driving distance of the grid from the landmark.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;cluster&lt;/strong&gt; is defined as a collection of landmarks, such that no pair of landmarks in a cluster are more than a specified δ driving distance away.&lt;/li&gt;
&lt;li&gt;With each grid, apart from the nearest landmark information, we additionally maintain a list of &amp;ldquo;walkable clusters&amp;rdquo;.
&lt;ul&gt;
&lt;li&gt;Walkable clusters of a grid are maintained as a list of tuples: $&amp;lt;C,w&amp;gt;$ , where $w$ is the distance of the nearest landmark in the cluster $C$ from the grid, and $w \leq W$ , where $W$ is another system parameter defining the maximum walking distance allowed by the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-finding-the-clusters&#34;&gt;4.2. Finding the Clusters&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Clusterminimization Problem&lt;/strong&gt; : The first step is to filter the set of landmarks to ensure that no two landmarks are located too close ($&amp;lt;f$ distance, where $f$ is a system parameter) to each other, as that would defy the purpose. At the same time, every landmark should be associated with a distinct cluster, and the number of clusters stored should be minimized, as otherwise, the efficiency of search query would be affected and we want to optimize the storage required in the RAM.&lt;/p&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_2_hubc61da1ffad89472c7ff0d95347a112c_39786_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_2_hubc61da1ffad89472c7ff0d95347a112c_39786_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;737&#34; height=&#34;358&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;Notations
&lt;ol&gt;
&lt;li&gt;$V$ : the set of (filtered) distinct landmarks, $|V|=n$ .&lt;/li&gt;
&lt;li&gt;$x_{i,j}$ : denote if landmark $i$ is mapped to the $j^{th}$ cluster.&lt;/li&gt;
&lt;li&gt;$m$ : the number of clusters used.&lt;/li&gt;
&lt;li&gt;$y_{j}$ : whether $j^{th}$ cluster is used.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The fourth inequality states that if two landmarks are part of the same cluster, then their pairwise distance should be at most $\delta$ .&lt;/li&gt;
&lt;li&gt;The underlying problem setting can be represented as an unweighted graph, where landmarks are vertices, and an edge between any two vertices exist if and only if the distance between the corresponding landmarks is $\leq \delta$ . Now, in this unweighted graph, the problem is equivalent to &lt;strong&gt;partition the graph in to min number of cliques&lt;/strong&gt;, such that every vertex is part of a clique.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-indexing-structure-for-efficient-searching&#34;&gt;4.3. Indexing Structure for Efficient Searching&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;entities that characterize a ride in XAR





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_3_huc865ac110cde490d977d5ae16740855d_223139_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_3_huc865ac110cde490d977d5ae16740855d_223139_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;752&#34; height=&#34;722&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each cluster has a list of rides associated with it as potential rides. With each cluster $C$ , this information is maintained as a list of tuples of the form: $&amp;lt;r,t &amp;gt;$ , where $r$ denotes a ride in the system, and $t$ is the estimated time of arrival of the ride in the cluster $C$ .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each ride created in the system is assigned a unique ride ID.&lt;/li&gt;
&lt;li&gt;The time of arrival is estimated from historical travel times.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The main idea is that any request originating in the reachable clusters of a pass-through cluster of a ride is a potential feasible match for the ride, and this can be determined dynamically too, while the vehicle is passing through the passthrough cluster. Once we identify the pass-through cluster and their associated reachable clusters for every segment of the route of a ride, the ride gets added to the list of potential rides associated with each of these clusters, maintaining the sorted order of the lists.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_4_hu6040f9ab68b6ae13af53e0b3f08882d2_240321_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_4_hu6040f9ab68b6ae13af53e0b3f08882d2_240321_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1254&#34; height=&#34;811&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;OpenStreetMap&lt;/li&gt;
&lt;li&gt;OpenTripPlanner&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/10</title>
      <link>/post/2020-2-10-1/</link>
      <pubDate>Mon, 10 Feb 2020 19:29:15 +0800</pubDate>
      <guid>/post/2020-2-10-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;To hire a vehicle, a passenger simply types in her/his desired pick up location and destination in the app and sends the request to the service provider, who either forwards the request to some drivers close to the pick up location, or directly schedule a close-by driver to take the order.&lt;/p&gt;
&lt;p&gt;However, there are some challenges of the problem:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The car-hailing supply-demand varies dynamically due to different geographic locations and time intervals.&lt;/li&gt;
&lt;li&gt;The order data contains multiple attributes. These attributes together provide a wealth of information for supply-demand prediction. However, it is nontrivial how to use all the attributes in a unified model.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;The paper&amp;rsquo;s &lt;strong&gt;goal&lt;/strong&gt; is to &lt;u&gt;predict the gap between the car-hailing supply and demand for a certain area in the next few minutes&lt;/u&gt;.&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-definition&#34;&gt;3.1. Definition&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spatio-temporal Processing&lt;/strong&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A city is divided into $N$ non-overlapping square areas $a_{1},a_{2},\cdots,a_{N}$ .&lt;/li&gt;
&lt;li&gt;Each day is divided into 1440 timeslots(one minute for one timeslot).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Car-hailing Order&lt;/strong&gt; :





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/definition_1_hu3dffc4dcb433b4345a1119954d41295c_40814_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/definition_1_hu3dffc4dcb433b4345a1119954d41295c_40814_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;551&#34; height=&#34;431&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Supply-demand Gap&lt;/strong&gt; : For the $d$-th day, the supply-demand gap of the time interval $[t,t+C)$ in area $a$ is defined as &lt;u&gt;the total amount of invalid orders in this time interval&lt;/u&gt;.  The constant $C$ is set as 10.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Weather Condition&lt;/strong&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the weather type $wc.type$&lt;/li&gt;
&lt;li&gt;the temperature $wc.temp$&lt;/li&gt;
&lt;li&gt;the PM2.5 $wc.pm$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Traffic Condition&lt;/strong&gt; : The traffic condition describes the congestion level of road segments in each area.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/definition_2_hu654ce091b558ddc51ba703a425c36e8a_16449_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/definition_2_hu654ce091b558ddc51ba703a425c36e8a_16449_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;771&#34; height=&#34;81&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-problem&#34;&gt;3.2. Problem&lt;/h3&gt;
&lt;p&gt;Suppose the current date is the $d$-th day and the current time slot is $t$ . Given the past order data and the past environment data, our goal is to predict the supply-demand gap $gap^{d,t}_{a}$ for every area $a$ , i.e., the supply-demand gap in the next 10 minutes.&lt;/p&gt;
&lt;h3 id=&#34;33-embedding-method&#34;&gt;3.3. Embedding Method&lt;/h3&gt;
&lt;p&gt;A function $f : X \rightarrow Y$ , satisfy two properties&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;injective&lt;/li&gt;
&lt;li&gt;structure-preserving&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;34-residual-network&#34;&gt;3.4. Residual Network&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/definition_3_hu336ebc7c04ef908dc0e77915f0bf9cb9_14030_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/definition_3_hu336ebc7c04ef908dc0e77915f0bf9cb9_14030_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;312&#34; height=&#34;296&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-basic-version&#34;&gt;4.1. Basic Version&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_1_hu59bccbcf4d822c4963c60812ca2fd14c_53855_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_1_hu59bccbcf4d822c4963c60812ca2fd14c_53855_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;732&#34; height=&#34;526&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;411-identity-part&#34;&gt;4.1.1. Identity Part&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;The identity features include the ID of area AreaID, the timeslot TimeID and the day of week (Monday, Tuesday, &amp;hellip;, Sunday) WeekID.&lt;/li&gt;
&lt;li&gt;Different areas at different time can share similar supply-demand patterns, especially when they are spatio-temporally close.&lt;/li&gt;
&lt;li&gt;The embedding method is used to reduce the feature dimensions and discover the similarities among different areas and timeslots.&lt;/li&gt;
&lt;li&gt;The Concatenate Layer takes a list of vectors as the input and simply outputs the concatenation of the vectors, denoted as $X_{id}$ .&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_2_hu05cfdc1b27797480a4e0abc2483f172e_47429_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_2_hu05cfdc1b27797480a4e0abc2483f172e_47429_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;502&#34; height=&#34;276&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;412-order-part&#34;&gt;4.1.2. Order Part&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The supply-demand block can be regarded as a three layer perception, which processes the order data.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The input layer is a &lt;strong&gt;real-time supply-demand vector&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;We then pass it through two Fully-Connected layers.&lt;/li&gt;
&lt;li&gt;The output of the supply-demand block is denoted as $X_{sd}$ .&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Real-time supply-demand vector&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For a specific area $a$ , to predict the supply-demand gap $gap^{d,t}_{a}$ of the time interval $[t, t + 10)$ in the $d$-th day, we consider the order set with timestamp in $[t − L, t)$ of the $d$-th day, which we denote as $S^{d,t}$ .&lt;/li&gt;
&lt;li&gt;For a specific area $a$ , we define the real-time supply-demand vector in the $d$-th day at timeslot $t$ as $V_{sd}^{d,t}$ .&lt;/li&gt;
&lt;li&gt;$V_{sd}^{d,t}$ is a 2L-dimensional vector, which consists of two parts :
&lt;ul&gt;
&lt;li&gt;The first $L$ dimensions describe the amount of valid orders at $t-L$ in the current day.&lt;/li&gt;
&lt;li&gt;The second $L$ dimensions correspond to the invalid orders in the previous $L$ minutes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_3_huba412e8c17b6be193c13503f58937574_60224_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_3_huba412e8c17b6be193c13503f58937574_60224_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;658&#34; height=&#34;347&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;413-environment-part&#34;&gt;4.1.3. Environment Part&lt;/h4&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_4_hu03c63d017adb013fe4f0177103091bd0_67445_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_4_hu03c63d017adb013fe4f0177103091bd0_67445_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;755&#34; height=&#34;661&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;42-advanced-version&#34;&gt;4.2. Advanced Version&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Extended Order Part&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_5_hu0e8c5e331888f5d3fea476b93648c330_30477_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_5_hu0e8c5e331888f5d3fea476b93648c330_30477_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;551&#34; height=&#34;370&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Historical supply-demand vector&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_6_hu088da2e61473079f8c62e2e6d158a635_29923_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_6_hu088da2e61473079f8c62e2e6d158a635_29923_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;731&#34; height=&#34;368&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Extended Supply-demand Block&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_7_hu8198f7966b4f561b8854888ee9279832_33732_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_7_hu8198f7966b4f561b8854888ee9279832_33732_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;672&#34; height=&#34;414&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Data set&lt;/strong&gt; : the public dataset released by Didi in the Di-tech supply-demand prediction competition&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/4</title>
      <link>/post/2020-2-4-1/</link>
      <pubDate>Tue, 04 Feb 2020 13:10:41 +0800</pubDate>
      <guid>/post/2020-2-4-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;There are three types of participants in the scenario: organization, drivers and passengers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Organization&lt;/strong&gt; : Organization is a company or a transportation authority that operates a dynamic taxi ridesharing service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Drivers&lt;/strong&gt; : Taxi drivers can independently determine when to join and leave the service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Passengers&lt;/strong&gt; : Passengers submit ride queries in real time via a mobile device&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each query indicates the &lt;u&gt;origin and destination locations of the trip&lt;/u&gt;, as well as &lt;u&gt;time windows constraining when the passenger wants to be picked up and dropped off&lt;/u&gt;.&lt;/p&gt;
&lt;p&gt;Once receiving a new query, the organization will dispatch an &amp;ldquo;appropriate&amp;rdquo; taxi which is able to satisfy both the new query and the trips of existing passengers who are already assigned to the taxi.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper propose a two-fold goal.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The first goal&lt;/strong&gt; is to investigate the potential of taxi ridesharing in serving more taxi ride queries by comparing with the case where no ridesharing is conducted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second goal&lt;/strong&gt; is to reduce the total travel distance of these taxis (so as to reduce the energy consumption) when doing the ridesharing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the problem is to build a dynamic ridesharing service applicable for the practical use, i.e. serving a large number of queries quickly. &lt;u&gt;To achieve this purpose, two issues need to be addressed.&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The first issue&lt;/strong&gt; : How to quickly search an &amp;ldquo;appropriate&amp;rdquo; taxi from a large number of candidate cars?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second issue&lt;/strong&gt; : How to accelerate the computation of shortest paths since the shortest path calculation is usually complicated?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-definition&#34;&gt;3.1. Definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Query&lt;/strong&gt; : A query Q is a passenger’s request for a taxi ride.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/query_hud347ee22c158084d84b8812f6b857e6a_9338_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/query_hud347ee22c158084d84b8812f6b857e6a_9338_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;481&#34; height=&#34;81&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Schedule&lt;/strong&gt; : A schedule S is a temporally-ordered sequence of pickup and delivery points.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/schedule_hu47c934b410a1689cc18669ba9768b129_5600_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/schedule_hu47c934b410a1689cc18669ba9768b129_5600_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;221&#34; height=&#34;101&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Taxi Status&lt;/strong&gt; :  A taxi status V represents the instantaneous state of a taxi.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/taxi_status_hu6418551d827abec3032b98b822b04033_16114_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/taxi_status_hu6418551d827abec3032b98b822b04033_16114_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;840&#34; height=&#34;131&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Satisfaction&lt;/strong&gt; : Given a taxi status V and a query Q, the paper says that V satisfies Q iff
&lt;ol&gt;
&lt;li&gt;The number of on-board passengers is smaller than the capacity of the taxi.&lt;/li&gt;
&lt;li&gt;The taxi can pickup and drop off Q and other on-board passengers without violating the time constraint.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-problem&#34;&gt;3.2. Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The Dynamic Taxi Ridesharing Problem&lt;/strong&gt; : Given a fixed number of taxis traveling on a road network and a stream of queries (i.e. a sequence of queries in ascending order of their birth time), the paper aims to &lt;u&gt;serve each query in the stream by dispatching the taxi which satisfies with minimum additional incurred travel distance on the road network&lt;/u&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; The paper aims to minimize the increased travel distance for each individual query. This is obviously a greedy strategy and it does not guarantee that the total travel distance of all taxis for all queries is minimized. &lt;u&gt;Howerver, the problem of optimizing travel distance for all taxis for the whole query stream has been proved to be NP-complete by reducing to the Travelling Salesman Problem with Time Window.&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-framework&#34;&gt;3.3. Framework&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/framework_hu80a8d6d7f84148f102c61f3aba0566fb_75147_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/framework_hu80a8d6d7f84148f102c61f3aba0566fb_75147_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;513&#34; height=&#34;459&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-a-spatio-temporal-index-of-taxis&#34;&gt;4.1. A Spatio-temporal Index of Taxis&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : It needs to use the query’s time windows to filter out unsatisfactory taxis. The authors want a taxi searching process that is both fast and selects taxis wisely such that the selected taxis can satisfy the query with a reasonable small increase in travel distance over their existing schedules. If we use a pre-computed distance to approximate the distance of the shortest path, though the distance is not exact anymore, the time-consuming problem completely goes away.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We partition the road network using a grid. Within each grid cell, we choose the road network node which is closest to the geographical centre of the cell as the anchor node of the cell. The anchor node of a grid cell $g_{i}$ is thereafter denoted by $c_{i}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_1_huf29fbc3cd8f55bc41b1972a0aa4ee356_31851_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_1_huf29fbc3cd8f55bc41b1972a0aa4ee356_31851_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;321&#34; height=&#34;312&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We pre-compute the distance, denoted by $d_{ij}$ , and travel time, denoted by $t_{ij}$ , of the shortest path on the road network for each anchor node pair $c_{i}$ and $c_{j}$ . The distance and travel time results are saved in a matrix. The matrix is thereafter referred to as the grid distance matrix.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_2_huc544431513aa519ce59bb06262b6fd41_25966_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_2_huc544431513aa519ce59bb06262b6fd41_25966_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;366&#34; height=&#34;315&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Now imagine that each grid cell collapses to its anchor node, that is, all the points in one cell fall to its anchor node. Then the distance between any two arbitrary points equals to the distance between two corresponding anchor nodes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each cell has some internal data structure for the purpose of taxi searching. Specifically, each grid cell $g_{i}$ maintains three lists: a temporally-ordered grid cell list $(g_{i}.l_{g}^{t})$ , a spatially-ordered grid cell list $(g_{i}.l_{g}^{d})$ , and a taxi list $(g_{i}.l_{v})$ . The spatial and temporal closeness between each pair of grid cells are measured by the values saved in the grid distance matrix.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_3_hu2d038ac018bc8d992497e2484a0723fd_26837_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_3_hu2d038ac018bc8d992497e2484a0723fd_26837_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;520&#34; height=&#34;299&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each taxi ID is also tagged with a timestamp $t_{a}$ indicating when the taxi will enter the grid cell. Specifically, taxi $V_{j}$ is removed from the list when $V_{j}$ leaves $g_{i}$ ; taxi $V_{k}$ is inserted into the list when $V_{j}$ is newly scheduled to enter $g_{i}$ .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-taxi-searching-algorithms&#34;&gt;4.2. Taxi Searching Algorithms&lt;/h3&gt;
&lt;h4 id=&#34;421-single-side-taxi-searching&#34;&gt;4.2.1. Single-side Taxi Searching&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : We use query&amp;rsquo;s late pick-up timestamp to filter out grids, then filter the possible taxis from the candidate grids.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Suppose a passenger commits a query $Q$ located at grid $g_{7}$ at the time of $t_{cur}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_1_hu7d7e326b5cd973f956622b15ceb057ed_98800_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_1_hu7d7e326b5cd973f956622b15ceb057ed_98800_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;638&#34; height=&#34;387&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Any other arbitrary grid cell is selected by the searching algorithm if and only if
$$t_{i7} + t_{cur} \leq Q.wp.l$$
$t_{i7}$ indicates the travel time from grid $g_{i}$ to grid $g_{7}$ . To quickly find all grids hold the equation above, the single-side searching algorithm simply tests all grid cells in the order-preserved list $g_{7}.l_{g}^{t}$ and finds the first grid $g_{f}$ fails to hold the equation. Then the grids before $g_{f}$  in the list $g_{7}.l_{g}^{t}$ are selected as candidate taxis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For  each selected grid cell $g_{s}$ , the algorithm selects taxis (in $g_{s}.l_{v}$) whose $t_{a}$ is no later than $Q.wp.l - t_{s7}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_2_hub75161ce21867257f31b85020308e40b_30416_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_2_hub75161ce21867257f31b85020308e40b_30416_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;589&#34; height=&#34;249&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Weakness&lt;/strong&gt; : Unfortunately, this algorithm only considers taxis currently &amp;ldquo;near&amp;rdquo; the pickup point of a query (thus called single-side search). As the number of selected grid cells could be large, this algorithm may result in many taxis retrieved for the later scheduling module (therefore increasing the entire computation cost).&lt;/p&gt;
&lt;h4 id=&#34;422-dual-side-taxi-searching&#34;&gt;4.2.2. Dual-Side Taxi Searching&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : The spatio-temporal factor on the delivery point of queries also provides us with opportunities to reduce the number of grid cells to be selected. A dual-side searching algorithm is proposed as an effort for striking a balance between the distance optimality and the computation cost.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Suppose the deliver point is at grid $g_{2}$ . Any grid cell $g_{j}$ other than $g_{2}$ is selected by the searching algorithm at side if and only if the equation below holds, which means that any taxi currently in can enter before the late bound of the delivery window.
$$t_{cur}+t_{j2} \leq Q.wd.l$$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_3_hu31892b81786e77bcee49283119a63262_101906_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_3_hu31892b81786e77bcee49283119a63262_101906_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;665&#34; height=&#34;376&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The algorithm mantains a set $S_{o}$ and a set $S_{d}$ to store the taxis selected from $Q.o$ and $Q.d$ side respectively.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Initially, both and are empty.&lt;/li&gt;
&lt;li&gt;The first step in the searching is to add the taxis selected from taxi list $g_{7}.l_{v}$ to set $S_{o}$ , and add the taxis selected from taxi list $g_{2}.l_{v}$ to set $S_{d}$ . Then the algorithm calculates the intersection of $S_{o}$ and $S_{d}$ .&lt;/li&gt;
&lt;li&gt;If the intersection is not empty, the algorithm stops immediately and returns the intersection set. Otherwise, it expands the searching area by including one other grid cell at each side at a time.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_4_hua22a83df82277672b1b2b72fdfd73af6_110070_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_4_hua22a83df82277672b1b2b72fdfd73af6_110070_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;640&#34; height=&#34;625&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-scheduling-module&#34;&gt;4.3. Scheduling Module&lt;/h3&gt;
&lt;h4 id=&#34;431-insertion-feasibility-check&#34;&gt;4.3.1. Insertion Feasibility Check&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The insertion can be separated into two stages: (i) insert the pickup point of the query $Q.o$ ; (ii) insert the delivery point of the query $Q.d$ . Among all possible ways of insertion, the system chooses the insertion way that minimally increases the travel distance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An insertion feasibility check is done before an insertion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The passenger should be picked up before $Q.wp.l$ .&lt;/li&gt;
&lt;li&gt;Travel time delay $t_{d}$ should not result the late arrival at any point after the insertion.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The increased travel distance is calculated when both $Q.o$ and $Q.d$ are inserted successfully.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_3_1_hu943817b818205cb3f2c05fa79d2c2b07_37963_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_3_1_hu943817b818205cb3f2c05fa79d2c2b07_37963_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;672&#34; height=&#34;186&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;432-lazy-shortest-path-calculation-strategy&#34;&gt;4.3.2. Lazy Shortest Path Calculation Strategy&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : The paper aims to expedite the insertion process by speeding up the calculation itself instead of eliminating some insertion possibilities.&lt;/p&gt;
&lt;p&gt;The calculation of shortest path is deferred or avoided by the following logic:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the shortest path between the origin location O and the destination location D has been previously calculated, then the algorithm simply retrieves the path from the cached results.&lt;/li&gt;
&lt;li&gt;Otherwise, instead of directly calculating the shortest path, the algorithm first calculates the lower bound of the travel time between O and D using the precomputed travel time between grid cells and the triangle inequality. Only when the lower bound does not violate time constraints, the algorithm needs to proceed to compute the shortest-time path between points O and D.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is evident that the grid size will affect the effectiveness of lazy shortest path calculation strategy. State-of-art shortest path algorithms can be applied to speed up on-line shortest path calculations.&lt;/p&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Measurements
&lt;ol&gt;
&lt;li&gt;Relative Distance Rate (RDR) : Define the distance of a query $Q$ as the distance between its pickup point $Q.o$ and its delivery point $Q.d$ . Denote by $D_{SQ}$ the sum of distances of queries that get satisfied and by $D_{V}$ the total distance travelled by all taxis in the ridesharing.
$$RDR = D_{V}/D_{SQ}$$&lt;/li&gt;
&lt;li&gt;Satisfaction Rate (SR) : is the fraction of queries get satisfied in the ridesharing (exclude queries that are already served by taxis at the initial state in the query counting).&lt;/li&gt;
&lt;li&gt;Number of Road Nodes Accessed Per Query (#RNAPQ) : is the number of accessed road network nodes per query.&lt;/li&gt;
&lt;li&gt;Number of Grid Cells Accessed Per Query (#GCAPQ) : is the number of accessed grid cells per query.&lt;/li&gt;
&lt;li&gt;Number of Taxis Accessed Per Query (#TAPQ) : This measurement records how many taxis per query are accessed for insertion feasibility checks by the scheduling module.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
