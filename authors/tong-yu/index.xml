<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tong Yu</title>
    <link>/authors/tong-yu/</link>
      <atom:link href="/authors/tong-yu/index.xml" rel="self" type="application/rss+xml" />
    <description>Tong Yu</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 24 Feb 2020 13:18:08 +0800</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Tong Yu</title>
      <link>/authors/tong-yu/</link>
    </image>
    
    <item>
      <title>Paper Note - 2020/2/24</title>
      <link>/post/2020-2-24-1/</link>
      <pubDate>Mon, 24 Feb 2020 13:18:08 +0800</pubDate>
      <guid>/post/2020-2-24-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;A core operation in dynamic ridesharing is the “&lt;strong&gt;insertion operator&lt;/strong&gt;”.  The insertion operator has a time complexity of $O(n^3)$ , where $n$ is the number of all requests assigned to the worker.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;In this paper, the authors propose a novel partition framework and a dynamic programming based insertion with a time complexity of $O(n^2)$ .&lt;/li&gt;
&lt;li&gt;They further improve the time efficiency of the insertion operator to $O(n)$ harnessing efficient index structures, such as fenwick tree.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Flow Time&lt;/strong&gt; : Given a worker $w$ , a request set $R$ and a feasible route $S_R$ , the flow time of each request $r \in R$ is the duration between $t_r$ and the time $r$ is delivered(denoted by $delv(r)$), i.e. $flw(r) = delv(r) − t_r$ .
&lt;ul&gt;
&lt;li&gt;$t_r$ : release time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Insertion Operator&lt;/strong&gt; : Given a worker $w$ , a feasible route $S_R$ , and a new request $r$ , the insertion operator inserts $o_{r&amp;rsquo;}$ and $d_{r&amp;rsquo;}$ into $S_R$ to obtain a new feasible route $S_{R^+}$ ($ R^+ = R \cup \{ r&amp;rsquo;\}$).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objective Functions&lt;/strong&gt; :





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/object_hu9ffd07dfd8523ffdd92115f54c1e2a27_32000_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/object_hu9ffd07dfd8523ffdd92115f54c1e2a27_32000_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;657&#34; height=&#34;209&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-a-partition-based-framework&#34;&gt;4.1. A Partition-Based Framework&lt;/h3&gt;
&lt;p&gt;The &lt;strong&gt;key enabler&lt;/strong&gt; is to check constraints and calculate the objective in $O(1)$ time using the partition framework rather than in $O(n)$ time.&lt;/p&gt;
&lt;h4 id=&#34;411-rationale-of-partition&#34;&gt;4.1.1. Rationale of Partition&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;The key observation of the partition-based framework is that we can &lt;strong&gt;partition the requests into four disjoint sets&lt;/strong&gt; and handle their constraints and objective &lt;strong&gt;independently&lt;/strong&gt;. The partition of requests is based on the concept of &lt;strong&gt;detour&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Detour&lt;/strong&gt; : A detour represents the increased travel time after inserting a new location compared with the travel time of the original route. Formally, the detour $det(k, p)$ of inserting origin/destination $p$ between $k$-th location and $(k + 1)$-th location of route $S_R$ can be calculated as below
$$ det(k,p) = dis(l_k,p) + dis(p,l_{k+1}) - dis(l_k,l_{k+1})$$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/method_1_hufce73d8be5a582f4a80b5989282c9aa0_45180_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/method_1_hufce73d8be5a582f4a80b5989282c9aa0_45180_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;555&#34; height=&#34;165&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;According to the difference in the impact of detours due to insertion $(i,j)$ of a new request $r$ , we can now partition all the requests into four disjoint sets.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/method_2_hu641ef63ba729298b35d002ae70fda1aa_66100_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/method_2_hu641ef63ba729298b35d002ae70fda1aa_66100_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;581&#34; height=&#34;172&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;$R_1$ contains the requests whose destinations are before the $i$-th location ($i$ included). All the requests in this set are not influenced by the detour of inserting $o_{r&amp;rsquo;}$ and $d_{r&amp;rsquo;}$ .&lt;/li&gt;
&lt;li&gt;$R_2$ contains the requests whose destinations are between the $i$-th location ($i$ excluded) and the $j$-th location ($j$ included). All the requests in this set are influenced by detour of inserting $o_{r&amp;rsquo;}$ .&lt;/li&gt;
&lt;li&gt;$R_3$ contains the requests whose destinations are after the $j$-th location ($j$ excluded). All the requests in this set are influenced by detours of inserting $o_{r&amp;rsquo;}$ and $d_{r&amp;rsquo;}$ .&lt;/li&gt;
&lt;li&gt;$R_4$ contains the new request $r&#39;$ , which causes the detour.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/object_2_hu15dd6f0535a2563e9bb378590f99b691_45630_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/object_2_hu15dd6f0535a2563e9bb378590f99b691_45630_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;666&#34; height=&#34;327&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;412-naive-dynamic-programming-based-insertion&#34;&gt;4.1.2. Naive Dynamic Programming Based Insertion&lt;/h4&gt;
&lt;p&gt;The key insight is that the partition allows pre-calculation of some variables such that checking constraints and calculating the objectives can be performed in $O(1)$ time rather than $O(n)$ .&lt;/p&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/method_3_hudc0fc47b2d47bd0bd03a742100719693_129157_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/method_3_hudc0fc47b2d47bd0bd03a742100719693_129157_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;774&#34; height=&#34;720&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;42-a-segment-based-dp-algorithm&#34;&gt;4.2. A Segment Based DP Algorithm&lt;/h3&gt;
&lt;p&gt;




  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/method_4_hud720541b762436ea8cb5d85bb85340bd_164541_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/method_4_hud720541b762436ea8cb5d85bb85340bd_164541_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;770&#34; height=&#34;826&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;






  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-24-1/method_5_hu603695ec5adcc277b372df528dd394e6_138245_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-24-1/method_5_hu603695ec5adcc277b372df528dd394e6_138245_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;655&#34; height=&#34;405&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;nil&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/23</title>
      <link>/post/2020-2-23-1/</link>
      <pubDate>Sun, 23 Feb 2020 15:47:03 +0800</pubDate>
      <guid>/post/2020-2-23-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;Existing works in spatial matching or taxi dispatching only consider the pickup locations of riders and try to minimize the travel distance of taxis to pick riders, which causes that some taxis will be hard to pick up new convenient riders after their last riders unless move long distances to far away riders and results in the low efficiency of the platform.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper investigates a queueing-theoretic dispatching framework in this paper, which aims to take riders’ destinations into consideration to alleviate the shortage of taxis in particular areas such that the overall revenue of the platform can be maximized.&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The entire space is divided into a set of $n$ regions/grids $A=\{ a_1,a_2,\cdots,a_n \}$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rider&lt;/strong&gt; : The rider $r_i$ , who submit his/her order $o_i$ to the platform at timestamp $t_i$ , and is associated with a source location $s_i$ , a destination location $e_i$ and a pickup deadline $\tau_i$ .&lt;/li&gt;
&lt;li&gt;If a rider $r_i$ is delivered to his/her destination, the platform will &lt;strong&gt;charge&lt;/strong&gt; him/her for $\alpha \cdot cost(s_i, e_i)$, where $\alpha$ is the travel fee rate of the platform.&lt;/li&gt;
&lt;li&gt;Let $d_j$ be a driver, who is located position $l_j(t)$ at timestamp $t$ . Her status is either busy or available.&lt;/li&gt;
&lt;li&gt;For region $a_k$ at timestamp $t$ , we denote the set of available drivers as $D_k(t)$ and the number of them as $|D_k(t)|$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maximum Revenue Vehicle Dispatching Problem&lt;/strong&gt; : For a given time period $\mathbb{T}$ , a set of riders $R_{\mathbb{T}}$ and a set of drivers $D_{\mathbb{T}}$ may dynamically join or leave the platform. The MRVD problem is to select a set, $I_{\mathbb{T}}$ , of valid rider-and-driver dispatching pairs such that the overall revenue of the platform is maximized.
$$ \max \sum_{&amp;lt;r_i,d_i&amp;gt; \in I_{\mathbb{T}}}{\alpha \cdot cost(s_i,e_i)} $$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reduction of MRVD&lt;/strong&gt; :  Let $\psi_{ij}$ be the idle time of driver $d_j$ after delivering rider $r_i$ .
$$ \min \sum_{d_j \in d_{\mathbb{T}}} \sum_{i=0}^{R_j}{\psi_{ij}} $$&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-23-1/framework_huc1de902a645528f77d2660ac8a5d8375_138400_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-23-1/framework_huc1de902a645528f77d2660ac8a5d8375_138400_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;631&#34; height=&#34;481&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Idle Ratio Oriented Greedy Approach&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We iteratively assign drivers to riders every $\delta$ seconds. The current scheduling time period $[\bar{t},\bar{t}+t_c]$ is a time period where we consider the arrivals of drivers and riders follow Poisson distributions for each region.&lt;/li&gt;
&lt;li&gt;The idle ratio of driver $d_j$ to server rider $r_i$ :
$$ IR(r_i,d_j) = \cfrac{ET(\lambda_{(k)},\mu_{(k)})}{ cost(s_i,e_i)+ET(\lambda_{(k)},\mu_{(k)}) } $$
&lt;ul&gt;
&lt;li&gt;$ET(\lambda_{(k)},\mu_{(k)})$ : the expected idle time of driver $d_j$ when he/she rejoins the platform at region $a_k$&lt;/li&gt;
&lt;li&gt;We only need to greedily select the rider-and-driver dispatching pairs with low idle ratio.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;















&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;method&#34; &gt;


  &lt;img src=&#34;method&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;nil&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/22</title>
      <link>/post/2020-2-22-1/</link>
      <pubDate>Sat, 22 Feb 2020 15:10:51 +0800</pubDate>
      <guid>/post/2020-2-22-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;Vehicle shortage is not uncommon in popular ridesharing platforms. The shortage of vehicle disables the platform from dispatching all orders immediately, and some requesters would have to wait if their orders are pended. In practice, requesters who are anxious and not cost-sensitive, may wish to pay more to get dispatch priority.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;An auction-based order dispatch and pricing mechanism are proposed.&lt;/strong&gt; In this auction mechanism, the requesters(riders) act as buyers. They submit origins &amp;amp; destinations and bids to the platform server. With bids, the requesters claim the amount of money they would like to pay to take the service. The platform acts as the auctioneer, selling the shard-rides to requesters. With respect to their bids, the platform computes a dispatch, and decides the final payments of dispatched requesters.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;The proposed algorithms manage to maximize the overall utility of the auction, which is comprised of requesters’ utility, drivers’ utility, and platform’s utility.&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-symbols&#34;&gt;3.1. Symbols&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/symbol_hu3dd0bc9f55fadd58d3e60c6aafe9c868_104313_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/symbol_hu3dd0bc9f55fadd58d3e60c6aafe9c868_104313_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;776&#34; height=&#34;465&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;32-entity-models&#34;&gt;3.2. Entity Models&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;We adopt the round-based order dispatch model for our mechanism. In each round, the platform server operates on a set of pended orders and online vehicles to optimize some objectives.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wasted time&lt;/strong&gt; :  the wasted time of a dispatched requester $r_j$ is $wt_j + dt_j$
&lt;ul&gt;
&lt;li&gt;$wt_j$ : his/her waiting time during pick-up&lt;/li&gt;
&lt;li&gt;$dt_j$ : his/her detour time during delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Requester&lt;/strong&gt; : a requester rj is represented by a tuple $&amp;lt;s_j,e_j,\theta_j,val_j,bid_j&amp;gt;$
&lt;ul&gt;
&lt;li&gt;$s_j$ and $e_j$ : starting and ending geographical locations of its trip&lt;/li&gt;
&lt;li&gt;$val_j$ and $bid_j$ : $r_j$’s valuation of the service and bid to the platform respectively&lt;/li&gt;
&lt;li&gt;$\theta_j$ : his/her maximum allowed amount of wasted time during pick-up and delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vehicle&lt;/strong&gt; : $&amp;lt;l_i,pl_i&amp;gt;$
&lt;ul&gt;
&lt;li&gt;$l_i$ : its current location&lt;/li&gt;
&lt;li&gt;$pl_i$ : its travel plan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Validity of travel plans&lt;/strong&gt; : precedence constraint, capacity constraint, time constraint&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Payments to vehicles&lt;/strong&gt; : We assume platform’s payment to a vehicle is proportional to its travel distance after it picks up the first rider. Let $rev_i$ denote the revenue of $v_i$ .
&lt;ul&gt;
&lt;li&gt;$rev_i = \beta_d * D_i$&lt;/li&gt;
&lt;li&gt;$\beta_d$ : the payment to vehicle per unit travel distance&lt;/li&gt;
&lt;li&gt;$D_i$ : the travel distance of $v_i$ during delivery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-problem-formulation&#34;&gt;3.3. Problem Formulation&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Requester’s utility&lt;/strong&gt; : $u_j = (val_j - pay_j) \cdot x_j$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x_j$ equals 1 if the order of $r_j$ is dispatched, or 0 otherwise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Platform’s utility&lt;/strong&gt; : $U_{plf} = \sum_{r_j \in \hat{R}}{pay_j} - \sum_{v_i}{rev_i}$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\hat{R}$ : the set of dispatched requesters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Driver’s utility&lt;/strong&gt; : $u_i = rev_i -\alpha_d D_i = (\beta_d - \alpha_d)D_i$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\alpha_d$ : measures the labor &amp;amp; fuel cost per unit travel distance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Overall utility&lt;/strong&gt; : The utility of truthful auction in ridesharing is defined as the sum of requesters’ utilities, platform’s utility, and drivers’ utilities, i.e..





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/utility_hud7c2f055f314aea9d813532436946f75_45896_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/utility_hud7c2f055f314aea9d813532436946f75_45896_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;881&#34; height=&#34;325&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$bid_j = val_j$ because of auction truthfulness&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Order dispatch problem&lt;/strong&gt; : Given inputs of requester set $R$ and vehicle set $V$ , the order dispatch problem in auction-based ridesharing is to dispatch requesters $r_j \in R$ to vehicles $v_i \in V$ such that the overall utility is maximized.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Order pricing problem&lt;/strong&gt; : The order pricing problem is to determine the payment for each dispatched requester such that the auction mechanism &lt;strong&gt;satisfies the following properties&lt;/strong&gt;: truthfulness, individual rationality, profitability and computational efficiency.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Truthfulness&lt;/strong&gt; : An auction is truthful if the best strategy of any requester is to bid his/her valuation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Individual rationality&lt;/strong&gt; : An auction is individually rational if the utility of any requester is non-negative.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Profitability&lt;/strong&gt; : An auction is profitable if the utility of the platform is non-negative.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Computational efficiency&lt;/strong&gt; : An auction is computationally efficient if the process of winner selection and payment computation can finish within polynomial time.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The order dispatch problem is NP-hard.&lt;/p&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-the-greedy-approach&#34;&gt;4.1. The Greedy Approach&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Greedy-based order dispatch proceeds in two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Initialization&lt;/strong&gt; : It traverses all requester-vehicle pairs to find the valid dispatches, and calculates the corresponding utilities. Valid dispatch means that $pl_i$ remains valid after accommodating $r_j$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;One-by-one dispatch&lt;/strong&gt; : It keeps dispatching $(r_j∗, v_i∗)$ which brings the maximum utility among the remaining valid dispatches. The utility $u_{i,j}$ is calculated as $u_{i,j}=bid_j - \alpha_d * \Delta D_i(r_j)$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/algorithm_1_hu12ffe048d93267b1b9c0f253235a764d_135273_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/algorithm_1_hu12ffe048d93267b1b9c0f253235a764d_135273_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;735&#34; height=&#34;682&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Order pricing for greedy dispatch





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/algorithm_2_hu03ef167f1e1d95b1259d71af5defba46_120078_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/algorithm_2_hu03ef167f1e1d95b1259d71af5defba46_120078_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;770&#34; height=&#34;557&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-the-ranking-approach&#34;&gt;4.2. The Ranking Approach&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Order Dispatch
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Pack generation&lt;/strong&gt; : For each $r_j$ , we find its nearest vehicle, $v_{r_j}$ . Then, for each $r_j$ , we find the optimal pack which contains $r_j$ and has at most $\bar{c}$ requesters, such that dispatching this pack to one of their nearest vehicles yields the maximum utility.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pack dispatch&lt;/strong&gt; : The packs are ranked in descending order of their utilities. Then, they are dispatched in the order of their rankings. The algorithm firstly retrieves the pack with the highest ranking, $pack_{j∗}$ among the remaining packs. Then, it dispatches $pack_{j∗}$ to its vehicle $v_{pack_{j∗}}$ . Finally, it removes the remaining packs whose requesters or vehicles are occupied by $pack_{j∗}$ . The pack dispatch process terminates when $Rank$ becomes empty.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-22-1/algorithm_3_hud73abff544603dddf1a5a9f6c8b0501c_139310_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-22-1/algorithm_3_hud73abff544603dddf1a5a9f6c8b0501c_139310_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;783&#34; height=&#34;639&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;Data set : Beijing, Didi.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/17</title>
      <link>/post/2020-2-17-1/</link>
      <pubDate>Mon, 17 Feb 2020 13:18:21 +0800</pubDate>
      <guid>/post/2020-2-17-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Ridesharing refers to a transportation scenario where travellers with similar itineraries and time schedules share a vehicle for a trip and split the travel costs such as fuel, tolls, and parking fees.&lt;/li&gt;
&lt;li&gt;When travellers need to travel to some destination, they often &lt;strong&gt;have several options&lt;/strong&gt; to choose among. In such a setting, the cost and travel time of an option are important decision criteria.&lt;/li&gt;
&lt;li&gt;In the paper, it&amp;rsquo;s assumed that the destination of a vehicle is not limited and that it can accommodate any number of rider groups during a trip as long as it satisfies a capacity constraint.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;Given a set of vehicles $C$ in the road network $G$ at a specific time and a real-time trip request set $S_{R}$ , dynamic ridesharing finds, for each trip request $R \in S_{R}$ , &lt;u&gt;all qualified and non-dominated results &lt;/u&gt; $&amp;lt;c, time, price&amp;gt;$ .&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-symbols&#34;&gt;3.1. Symbols&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-17-1/symbol_hu0609361d40184b3cb86646c0ec4482bd_209770_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-17-1/symbol_hu0609361d40184b3cb86646c0ec4482bd_209770_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;744&#34; height=&#34;671&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;32-definition&#34;&gt;3.2. Definition&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Ridesharing Request&lt;/strong&gt; : A ridesharing request $R=&amp;lt;s,d,n,w,\epsilon&amp;gt;$ on a road network $G$ is defined by a start location $s$ , a destination location $d$ ,  a number $n$ of riders, a maximal waiting time $w$ , and a service constraint $\epsilon$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vehicle Trip Schedule&lt;/strong&gt; : Each trip schedule $tr=&amp;lt;o_{1},o_{2},\cdots,o_{k}&amp;gt;$ contains a sequence of locations, where $o_{1}$ is the current location $c.l$ of vehicle $c$ , and $o_{i}$ $(2 \leq i \leq k)$ denotes the start location or destination of an unfinished ridesharing request.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Schedule Constraint&lt;/strong&gt; : A valid trip schedule needs to satisfy the four following conditions
&lt;ol&gt;
&lt;li&gt;Capacity constraint&lt;/li&gt;
&lt;li&gt;Point order&lt;/li&gt;
&lt;li&gt;Waiting time constraint&lt;/li&gt;
&lt;li&gt;Service constraint&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Price Model&lt;/strong&gt; :  For a ridesharing request $R=&amp;lt;s,d,w,n,\epsilon&amp;gt;$ , assume that $tr_{i}$ is the current trip schedule of a vehicle $c$ and $tr_{i}$ is the new trip schedule after inserting $R$ into $tr_{i}$ , the price is computed  as $f_{n} \times (dist_{tr_{j}}-dist_{tr_{i}}+dist(s,d))$ , where $f_n$ is price ratio that depends on the number $n$ of riders.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-index-structures&#34;&gt;4.1. Index Structures&lt;/h3&gt;
&lt;h4 id=&#34;411-road-network-indexing&#34;&gt;4.1.1. Road Network Indexing&lt;/h4&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-17-1/method_1_hub8b1d46d20ff19fb3758aa4ae0691b19_111644_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-17-1/method_1_hub8b1d46d20ff19fb3758aa4ae0691b19_111644_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1053&#34; height=&#34;372&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;If an edge $e=(u,v)$ belongs to more than one grid cell, we call $u$ and $v$ &lt;strong&gt;border vertices&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;To estimate the shortest path distance precisely, we maintain a matrix $M$ that stores the lower bound distance for every grid cell pair.&lt;/li&gt;
&lt;li&gt;Each grid cell maintains five lists :
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;border vertex list&lt;/strong&gt; : border vertices belonging to the grid cell&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vertex list&lt;/strong&gt; : vertices belonging to the grid cell, as each vertex $v$ is associated with its &lt;u&gt;shortest path distances&lt;/u&gt; to the border vertices ($BV$) of the grid cell ($\{ &amp;lt; u,dist(v,u) &amp;gt; | u \in BV \}$) and is also associated with $\min \{ dist(v,u)  | u \in BV \} $ (denoted as $v.min$ )&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;grid cell list&lt;/strong&gt; : other grid cells sorted in ascending order of the travel time from these grid cells to the grid cell.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;empty vehicle list&lt;/strong&gt; :  vehicles with empty ridesharing requests in $g_{i}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;non-empty vehicle list&lt;/strong&gt; : vehicles $c_j$ with a non-empty set of ridesharing requests, i.e., vehicles $c_j$ are currently located in $g_j$ or are scheduled to enter $g_{i}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lower Bound Distance&lt;/strong&gt; : Given a vertex $u$ in a grid cell $g_i$ and a vertex $v$ in a grid cell $g_j$ , if $g_i \neq g_j$ , then the lower bound distance $ldist(u, v) = D_{ij} + u.min + v.min$ ; if $gi = gj$ , then $ldist(u, v) = 0$ .&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upper Bound Distance&lt;/strong&gt; : if $g_i \neq g_j$ , then the upper bound distance $udist(u, v) = D_{ij} + dist(u, x_{ij}) + dist(v, y_{ij})$ ; if $g_i = g_j$ , then $udist(u, v) = \min \{dist(u, b) + dist(v, b) | b \in BV \}$ .&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;412-index-of-vehicle-trip-schedules&#34;&gt;4.1.2. Index of Vehicle Trip Schedules&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Representation of each vehicle $c$ :
&lt;ol&gt;
&lt;li&gt;the unique identifier $c.ID$ of the vehicle&lt;/li&gt;
&lt;li&gt;the current location $c.l$ of the vehicle&lt;/li&gt;
&lt;li&gt;the set $c.S$ of unfinished ridesharing requests assigned to it, sorted in ascending order of their timestamps&lt;/li&gt;
&lt;li&gt;the set $c.S_{tr}$ of all valid vehicle trip schedules&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The set $c.S_{tr}$ of all valid vehicle trip schedules can be managed by a 
&lt;a href=&#34;https://tong-yu-pluto.github.io/post/2020-2-7-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kinetic tree&lt;/a&gt;
. &lt;u&gt;Three variables are added&lt;/u&gt; to each node $o_x$ of the kinetic tree :
&lt;ol&gt;
&lt;li&gt;a current vehicle’s capacity&lt;/li&gt;
&lt;li&gt;the minimal detour distance allowed&lt;/li&gt;
&lt;li&gt;the trip distance disttr from $c$’s current location to $o_x$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-17-1/method_2_hu33ad4396c989b445384c3081596e05ce_100835_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-17-1/method_2_hu33ad4396c989b445384c3081596e05ce_100835_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;865&#34; height=&#34;478&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The following global information of each grid cell $g_j$ is maintained to facilitate the pruning of a whole grid cell :
&lt;ol&gt;
&lt;li&gt;the maximum capacity : $\max \{ o_x.capacity | &amp;lt;o_x, o_y&amp;gt; \in  g_j \}$&lt;/li&gt;
&lt;li&gt;the maximal detour allowed : $\max \{ o_x.detour | &amp;lt;o_x, o_y&amp;gt; \in  g_j \}$&lt;/li&gt;
&lt;li&gt;the minimal trip distance : $dist_{tr}=\min \{ o_x.dist_{tr} | &amp;lt;o_x, o_y&amp;gt; \in  g_j \}$&lt;/li&gt;
&lt;li&gt;the maximal shortest path distance : $dist=\max \{ dist(o_x,o_y) | &amp;lt;o_x,o_y&amp;gt; \in g_j \}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-pruning-heuristics&#34;&gt;4.2. Pruning Heuristics&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : Based on the designed road network and vehicle indexes, we use the lower and upper bound distances instead of the actual shortest path distances to estimate pick-up time and price for filtering.&lt;/p&gt;
&lt;h4 id=&#34;421-pruning-empty-vehicles&#34;&gt;4.2.1. Pruning Empty Vehicles&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Given a current valid result $r_i$, we try to derive :
&lt;ol&gt;
&lt;li&gt;the pruning conditions implying that the estimated result $r_j$ (i.e., the lower bound values) returned by $c_j$ is dominated by $r_i$&lt;/li&gt;
&lt;li&gt;the pruning conditions implying that $r_j$ (i.e., the upper bound values) returned by $c_j$ dominates $r_i$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Based on the main idea, we can filter out invalid vehicles and grids.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;422-pruning-non-empty-vehicles&#34;&gt;4.2.2. Pruning Non-Empty Vehicles&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Pruning for inserting start location $s$ .&lt;/li&gt;
&lt;li&gt;Pruning for inserting destination location $d$ .&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-ridesharing-matching-algorithms&#34;&gt;4.3. Ridesharing Matching Algorithms&lt;/h3&gt;
&lt;p&gt;refer to 
&lt;a href=&#34;https://tong-yu-pluto.github.io/post/2020-2-4-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tshare&lt;/a&gt;
&lt;/p&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;experiments on effect of&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the Number of Verified Grid Cells&lt;/li&gt;
&lt;li&gt;Waiting Time&lt;/li&gt;
&lt;li&gt;Service Constraint&lt;/li&gt;
&lt;li&gt;Capacity of Vehicle&lt;/li&gt;
&lt;li&gt;Number of Vehicles&lt;/li&gt;
&lt;li&gt;Grid Cell Size&lt;/li&gt;
&lt;li&gt;the Number of Requests&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/12</title>
      <link>/post/2020-2-12-1/</link>
      <pubDate>Wed, 12 Feb 2020 18:48:20 +0800</pubDate>
      <guid>/post/2020-2-12-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;Dynamic peer-to-peer ride sharing.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper proposes&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a hierarchical discretization of the geographical region using grids, landmarks and clusters with theoretical guarantees&lt;/li&gt;
&lt;li&gt;an efficient in-memory indexing of rides for maintaining spatio-temporal validity within a specified error tolerance&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-system-overview&#34;&gt;3. System Overview&lt;/h2&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/overview_hub884fbe196ff49b837e613841b2ee2a5_46173_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/overview_hub884fbe196ff49b837e613841b2ee2a5_46173_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;793&#34; height=&#34;474&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;XAR requires pre-processing of the geographical region where the system will be used.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The map-processor module in the pre-processing unit uses geographic information of the city from OpenStreetMap(OSM) to create grids and extract landmarks.&lt;/li&gt;
&lt;li&gt;Further, these landmarks are grouped together into clusters by the clustering module, using route information from OpenTripPlanner(OTP).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;XAR run-time unit kicks in when the system is actually deployed.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This unit provides functionalities like creating a ride offer in the system, finding matching rides for a request, booking seats in a matched ride and tracking rides in progress in real-time.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-hierarchical-three-tiered-region-discretization&#34;&gt;4.1. Hierarchical Three-tiered Region Discretization&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_1_hu28a9df1509d2f0dd946215cba8436c21_13989_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_1_hu28a9df1509d2f0dd946215cba8436c21_13989_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;257&#34; height=&#34;301&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;A &lt;strong&gt;grid&lt;/strong&gt; is defined as a bounded square geographical region.
&lt;ul&gt;
&lt;li&gt;Any location is numerically mapped to a unique (implicit) grid, given its latitude and longitude.&lt;/li&gt;
&lt;li&gt;We identify a grid by its centroid, and henceforth wherever we refer to distances from a grid, these are measured with respect to the centroid of the grid.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;landmark&lt;/strong&gt; is a point of interest in a geographical region, such as a bus stop, a mall or an important building, such that it is sufficiently far (at least a pre-specified $f$ distance away) from any other landmark.
&lt;ul&gt;
&lt;li&gt;Each landmark is associated with a set of grids, and each grid is associated with a unique landmark, that minimizes the maximum driving distance of the grid from the landmark.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;strong&gt;cluster&lt;/strong&gt; is defined as a collection of landmarks, such that no pair of landmarks in a cluster are more than a specified δ driving distance away.&lt;/li&gt;
&lt;li&gt;With each grid, apart from the nearest landmark information, we additionally maintain a list of &amp;ldquo;walkable clusters&amp;rdquo;.
&lt;ul&gt;
&lt;li&gt;Walkable clusters of a grid are maintained as a list of tuples: $&amp;lt;C,w&amp;gt;$ , where $w$ is the distance of the nearest landmark in the cluster $C$ from the grid, and $w \leq W$ , where $W$ is another system parameter defining the maximum walking distance allowed by the system.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-finding-the-clusters&#34;&gt;4.2. Finding the Clusters&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Clusterminimization Problem&lt;/strong&gt; : The first step is to filter the set of landmarks to ensure that no two landmarks are located too close ($&amp;lt;f$ distance, where $f$ is a system parameter) to each other, as that would defy the purpose. At the same time, every landmark should be associated with a distinct cluster, and the number of clusters stored should be minimized, as otherwise, the efficiency of search query would be affected and we want to optimize the storage required in the RAM.&lt;/p&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_2_hubc61da1ffad89472c7ff0d95347a112c_39786_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_2_hubc61da1ffad89472c7ff0d95347a112c_39786_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;737&#34; height=&#34;358&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;Notations
&lt;ol&gt;
&lt;li&gt;$V$ : the set of (filtered) distinct landmarks, $|V|=n$ .&lt;/li&gt;
&lt;li&gt;$x_{i,j}$ : denote if landmark $i$ is mapped to the $j^{th}$ cluster.&lt;/li&gt;
&lt;li&gt;$m$ : the number of clusters used.&lt;/li&gt;
&lt;li&gt;$y_{j}$ : whether $j^{th}$ cluster is used.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;The fourth inequality states that if two landmarks are part of the same cluster, then their pairwise distance should be at most $\delta$ .&lt;/li&gt;
&lt;li&gt;The underlying problem setting can be represented as an unweighted graph, where landmarks are vertices, and an edge between any two vertices exist if and only if the distance between the corresponding landmarks is $\leq \delta$ . Now, in this unweighted graph, the problem is equivalent to &lt;strong&gt;partition the graph in to min number of cliques&lt;/strong&gt;, such that every vertex is part of a clique.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-indexing-structure-for-efficient-searching&#34;&gt;4.3. Indexing Structure for Efficient Searching&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;entities that characterize a ride in XAR





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_3_huc865ac110cde490d977d5ae16740855d_223139_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_3_huc865ac110cde490d977d5ae16740855d_223139_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;752&#34; height=&#34;722&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each cluster has a list of rides associated with it as potential rides. With each cluster $C$ , this information is maintained as a list of tuples of the form: $&amp;lt;r,t &amp;gt;$ , where $r$ denotes a ride in the system, and $t$ is the estimated time of arrival of the ride in the cluster $C$ .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each ride created in the system is assigned a unique ride ID.&lt;/li&gt;
&lt;li&gt;The time of arrival is estimated from historical travel times.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The main idea is that any request originating in the reachable clusters of a pass-through cluster of a ride is a potential feasible match for the ride, and this can be determined dynamically too, while the vehicle is passing through the passthrough cluster. Once we identify the pass-through cluster and their associated reachable clusters for every segment of the route of a ride, the ride gets added to the list of potential rides associated with each of these clusters, maintaining the sorted order of the lists.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-12-1/method_4_hu6040f9ab68b6ae13af53e0b3f08882d2_240321_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-12-1/method_4_hu6040f9ab68b6ae13af53e0b3f08882d2_240321_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1254&#34; height=&#34;811&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;OpenStreetMap&lt;/li&gt;
&lt;li&gt;OpenTripPlanner&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/10</title>
      <link>/post/2020-2-10-1/</link>
      <pubDate>Mon, 10 Feb 2020 19:29:15 +0800</pubDate>
      <guid>/post/2020-2-10-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;To hire a vehicle, a passenger simply types in her/his desired pick up location and destination in the app and sends the request to the service provider, who either forwards the request to some drivers close to the pick up location, or directly schedule a close-by driver to take the order.&lt;/p&gt;
&lt;p&gt;However, there are some challenges of the problem:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The car-hailing supply-demand varies dynamically due to different geographic locations and time intervals.&lt;/li&gt;
&lt;li&gt;The order data contains multiple attributes. These attributes together provide a wealth of information for supply-demand prediction. However, it is nontrivial how to use all the attributes in a unified model.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;The paper&amp;rsquo;s &lt;strong&gt;goal&lt;/strong&gt; is to &lt;u&gt;predict the gap between the car-hailing supply and demand for a certain area in the next few minutes&lt;/u&gt;.&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-definition&#34;&gt;3.1. Definition&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Spatio-temporal Processing&lt;/strong&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A city is divided into $N$ non-overlapping square areas $a_{1},a_{2},\cdots,a_{N}$ .&lt;/li&gt;
&lt;li&gt;Each day is divided into 1440 timeslots(one minute for one timeslot).&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Car-hailing Order&lt;/strong&gt; :





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/definition_1_hu3dffc4dcb433b4345a1119954d41295c_40814_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/definition_1_hu3dffc4dcb433b4345a1119954d41295c_40814_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;551&#34; height=&#34;431&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Supply-demand Gap&lt;/strong&gt; : For the $d$-th day, the supply-demand gap of the time interval $[t,t+C)$ in area $a$ is defined as &lt;u&gt;the total amount of invalid orders in this time interval&lt;/u&gt;.  The constant $C$ is set as 10.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Weather Condition&lt;/strong&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the weather type $wc.type$&lt;/li&gt;
&lt;li&gt;the temperature $wc.temp$&lt;/li&gt;
&lt;li&gt;the PM2.5 $wc.pm$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Traffic Condition&lt;/strong&gt; : The traffic condition describes the congestion level of road segments in each area.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/definition_2_hu654ce091b558ddc51ba703a425c36e8a_16449_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/definition_2_hu654ce091b558ddc51ba703a425c36e8a_16449_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;771&#34; height=&#34;81&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-problem&#34;&gt;3.2. Problem&lt;/h3&gt;
&lt;p&gt;Suppose the current date is the $d$-th day and the current time slot is $t$ . Given the past order data and the past environment data, our goal is to predict the supply-demand gap $gap^{d,t}_{a}$ for every area $a$ , i.e., the supply-demand gap in the next 10 minutes.&lt;/p&gt;
&lt;h3 id=&#34;33-embedding-method&#34;&gt;3.3. Embedding Method&lt;/h3&gt;
&lt;p&gt;A function $f : X \rightarrow Y$ , satisfy two properties&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;injective&lt;/li&gt;
&lt;li&gt;structure-preserving&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;34-residual-network&#34;&gt;3.4. Residual Network&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/definition_3_hu336ebc7c04ef908dc0e77915f0bf9cb9_14030_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/definition_3_hu336ebc7c04ef908dc0e77915f0bf9cb9_14030_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;312&#34; height=&#34;296&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-basic-version&#34;&gt;4.1. Basic Version&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_1_hu59bccbcf4d822c4963c60812ca2fd14c_53855_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_1_hu59bccbcf4d822c4963c60812ca2fd14c_53855_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;732&#34; height=&#34;526&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;411-identity-part&#34;&gt;4.1.1. Identity Part&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;The identity features include the ID of area AreaID, the timeslot TimeID and the day of week (Monday, Tuesday, &amp;hellip;, Sunday) WeekID.&lt;/li&gt;
&lt;li&gt;Different areas at different time can share similar supply-demand patterns, especially when they are spatio-temporally close.&lt;/li&gt;
&lt;li&gt;The embedding method is used to reduce the feature dimensions and discover the similarities among different areas and timeslots.&lt;/li&gt;
&lt;li&gt;The Concatenate Layer takes a list of vectors as the input and simply outputs the concatenation of the vectors, denoted as $X_{id}$ .&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_2_hu05cfdc1b27797480a4e0abc2483f172e_47429_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_2_hu05cfdc1b27797480a4e0abc2483f172e_47429_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;502&#34; height=&#34;276&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;412-order-part&#34;&gt;4.1.2. Order Part&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The supply-demand block can be regarded as a three layer perception, which processes the order data.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The input layer is a &lt;strong&gt;real-time supply-demand vector&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;We then pass it through two Fully-Connected layers.&lt;/li&gt;
&lt;li&gt;The output of the supply-demand block is denoted as $X_{sd}$ .&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Real-time supply-demand vector&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For a specific area $a$ , to predict the supply-demand gap $gap^{d,t}_{a}$ of the time interval $[t, t + 10)$ in the $d$-th day, we consider the order set with timestamp in $[t − L, t)$ of the $d$-th day, which we denote as $S^{d,t}$ .&lt;/li&gt;
&lt;li&gt;For a specific area $a$ , we define the real-time supply-demand vector in the $d$-th day at timeslot $t$ as $V_{sd}^{d,t}$ .&lt;/li&gt;
&lt;li&gt;$V_{sd}^{d,t}$ is a 2L-dimensional vector, which consists of two parts :
&lt;ul&gt;
&lt;li&gt;The first $L$ dimensions describe the amount of valid orders at $t-L$ in the current day.&lt;/li&gt;
&lt;li&gt;The second $L$ dimensions correspond to the invalid orders in the previous $L$ minutes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_3_huba412e8c17b6be193c13503f58937574_60224_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_3_huba412e8c17b6be193c13503f58937574_60224_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;658&#34; height=&#34;347&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;413-environment-part&#34;&gt;4.1.3. Environment Part&lt;/h4&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_4_hu03c63d017adb013fe4f0177103091bd0_67445_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_4_hu03c63d017adb013fe4f0177103091bd0_67445_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;755&#34; height=&#34;661&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;42-advanced-version&#34;&gt;4.2. Advanced Version&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Extended Order Part&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_5_hu0e8c5e331888f5d3fea476b93648c330_30477_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_5_hu0e8c5e331888f5d3fea476b93648c330_30477_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;551&#34; height=&#34;370&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Historical supply-demand vector&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_6_hu088da2e61473079f8c62e2e6d158a635_29923_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_6_hu088da2e61473079f8c62e2e6d158a635_29923_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;731&#34; height=&#34;368&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Extended Supply-demand Block&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-10-1/method_7_hu8198f7966b4f561b8854888ee9279832_33732_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-10-1/method_7_hu8198f7966b4f561b8854888ee9279832_33732_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;672&#34; height=&#34;414&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Data set&lt;/strong&gt; : the public dataset released by Didi in the Di-tech supply-demand prediction competition&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/7</title>
      <link>/post/2020-2-7-1/</link>
      <pubDate>Fri, 07 Feb 2020 13:25:07 +0800</pubDate>
      <guid>/post/2020-2-7-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;Each request specifies two constraints :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Waiting Time&lt;/strong&gt; : defining the maximal time allowed between making the request and receiving the service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Service Constraint&lt;/strong&gt; : defining the acceptable extra detour time from the shortest possible trip duration.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When a new request is received, it is &lt;u&gt;evaluated immediately&lt;/u&gt; for server matching and scheduling.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;The goal is&lt;/strong&gt; to schedule requests in real-time and minimize the servers’ travel times to complete all committed services while meeting service guarantees.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Real-time Ridesharing&lt;/strong&gt; : Given a set of vehicles on the road network $G$ and a new incoming request $tr$ , find the vehicle that minimizes the overall trip cost for the augmented valid trip schedule.&lt;/p&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;A Road Network $G = &amp;lt;V,E,W&amp;gt;$ : consists of a vertex set $V$ and an edge set $E$. Each edge $(u,v)\in E$ is associated with a weight $W(u,v)$ indicating the traveling cost along the edge $(u,v)$ .&lt;/li&gt;
&lt;li&gt;A Path $p$ : is a vertex sequence.&lt;/li&gt;
&lt;li&gt;A Trip Request $tr = &amp;lt;s,e,w,\epsilon&amp;gt;$ :
&lt;ul&gt;
&lt;li&gt;$w$ : a maximal waiting time&lt;/li&gt;
&lt;li&gt;$\epsilon$ : a service constraint, bounding the overall time from $s$ to $e$ by $(1+\epsilon)d(s,e)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A General Trip Schedule $S$ : trip set of size $m$ can be described in a sequence of $3m$ elements
&lt;ul&gt;
&lt;li&gt;$s_i$ : where a rider is picked up&lt;/li&gt;
&lt;li&gt;$e_i$ : where a rider is dropped off&lt;/li&gt;
&lt;li&gt;$r_i$ : where a request is received&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A Valid Trip Schedule : A valid trip schedule for a trip set $TR$ satisfies three conditions:
&lt;ol&gt;
&lt;li&gt;Point order : $r_i \rightarrow s_i \rightarrow e_i$&lt;/li&gt;
&lt;li&gt;Waiting time constraint : $d_{T}(r_i,s_i) \leq w$&lt;/li&gt;
&lt;li&gt;Service constraint : $d_{T}(s_i,e_i) \leq (1+\epsilon)d(s_i, e_i)$&lt;/li&gt;
&lt;li&gt;Capacity limit&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;A low maintenance cost &lt;strong&gt;indexing method&lt;/strong&gt; is needed to filter out servers outside the waiting time constraint.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-kinetic-tree-approach&#34;&gt;4.1. Kinetic Tree Approach&lt;/h3&gt;
&lt;h4 id=&#34;411-basic-tree-structure&#34;&gt;4.1.1. Basic Tree Structure&lt;/h4&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-7-1/method_1_hu1ef46a03612231377385dac6109b3650_100924_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-7-1/method_1_hu1ef46a03612231377385dac6109b3650_100924_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;666&#34; height=&#34;698&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h4 id=&#34;412-main-idea&#34;&gt;4.1.2. Main Idea&lt;/h4&gt;
&lt;p&gt;When a server reaches a new pickup or dropoff location in the trip schedule, only those valid schedules which contain unfinished trips and share the same prefix so far (from the first pickup point of all the unfinished schedules to the current location in the trip schedule) need to be materialized. All other schedules become inactive and can be pruned from the tree.(&lt;u&gt;Only a valid trip schedule can be extended to accommodate a new request.&lt;/u&gt;)&lt;/p&gt;
&lt;h4 id=&#34;413-challenge&#34;&gt;4.1.3. Challenge&lt;/h4&gt;
&lt;p&gt;The problem is how to determine:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;at which edge $s_k$ or $e_k$ can be inserted&lt;/li&gt;
&lt;li&gt;how to quickly prune the invalid trip schedules following that insertion&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;414-inserting-pickup-location&#34;&gt;4.1.4. Inserting Pickup Location&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;We can perform either a depth first search (DFS) or breadth first search (BFS) starting from the root node of the tree to generate all the candidate edge $(x_i, x_{i+1})$ to insert $s_k$ .&lt;/li&gt;
&lt;li&gt;At any given point, the “active” customers can be partitioned into two sets:
&lt;ul&gt;
&lt;li&gt;$S_1$ records those customers who need to be picked up&lt;/li&gt;
&lt;li&gt;$S_2$ records the on-board customers who need to be dropped off&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For the sub-tree rooted at $x_i$ , the simple way is to first generate these two sets $S_1$ and $S_2$ . Then, when we insert $s_k$ , we need to ensure each condition associated with $S_1$ and $S_2$ are also satisfied.&lt;/li&gt;
&lt;/ol&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-7-1/method_2_hu15fec19835209d0aa330835d07ee9807_121201_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-7-1/method_2_hu15fec19835209d0aa330835d07ee9807_121201_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1558&#34; height=&#34;468&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;42-hotspot-based-optimization&#34;&gt;4.2. Hotspot Based Optimization&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Motivation&lt;/strong&gt; : The main problem with the basic tree algorithm is the exponential explosion of the size of the tree when there are multiple pickup or dropoff locations close to each other.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;When we insert a pickup point $s_k$ to an edge $(x_i, x_{i+1})$ , we check if $d(x_{i+1}, s_k) \leq \theta$ for small $\theta$ . If so, $s_k$ is inserted into the node of $x_{i+1}$ .&lt;/li&gt;
&lt;li&gt;$s_k$ and $x_{i+1}$ are treated as one point called a hotspot in the tree, and an arbitrary schedule is chosen between the points in a hotspot.&lt;/li&gt;
&lt;li&gt;When a hotspot contains more than one point, a newly inserted point must be within $\theta$ to all points of the hotspot.&lt;/li&gt;
&lt;li&gt;A similar procedure can be followed for dropoff points and mixtures of pickup and dropoffs.&lt;/li&gt;
&lt;li&gt;Once a point is combined with any hotspot, we stop trying to insert it to any other edges.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;Nothing special.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/5</title>
      <link>/post/2020-2-5-1/</link>
      <pubDate>Wed, 05 Feb 2020 19:34:40 +0800</pubDate>
      <guid>/post/2020-2-5-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Passenger&lt;/strong&gt; : A person uses the cell app (or a regular phone call to a taxi company) specifying its current location, destination, and others informations such as a maximum delay that he is available to accept (the delay is in comparison with a sole taxi trip).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Driver&lt;/strong&gt; :  Car owners and riders specify their origins and destinations. Car owners also indicate a maximum delay they can accept.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Plateform&lt;/strong&gt; : If a user gets a shared trip, the system must guarantee that it is cheaper than the trip where he goes alone, and that he arrives at his destination within the maximum delay specified. Based on the car gas price and consumption per kilometer, the system computes matchings between car owners and riders.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper focuses principally on the optimization problem that we call &lt;strong&gt;dynamic taxi sharing with time windows problem&lt;/strong&gt; (TSTWP).&lt;/p&gt;
&lt;p&gt;Several &lt;strong&gt;constraints&lt;/strong&gt; must be considered:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the vehicle capacity&lt;/li&gt;
&lt;li&gt;the cost of a shared ride must not exceed the cost of a private ride&lt;/li&gt;
&lt;li&gt;each passenger and taxi has time window&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This paper wants to &lt;u&gt;maximize the number of served requests&lt;/u&gt; and minimize the total cost incurred to passengers, which is the same as maximize the sharing. The goals are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;The first goal&lt;/strong&gt; : Maximize the number of served requests.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second goal&lt;/strong&gt; : Minimize the cost payed by the served passengers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;P.S. There is an &lt;u&gt;upper bound&lt;/u&gt; for the second objective, by computing the cost of each trip as a private trip.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;hard part&lt;/strong&gt; is&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time&lt;/strong&gt; : No one can arrive at its destination later than its maximum allowable time, and no one is served before its service time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Costs&lt;/strong&gt; : A taxi passenger on a shared trip can not spend more money than on a sole trip. A car owner interested in offering rides, must receive at least as much he spend doing an alternative route, instead of his shortest path route.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Safety&lt;/strong&gt; : The system used by hitchhikers and car owners requires a previous registration. Users can specify that they only ride with friends of friends for example, using data from social networks.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-formal-problem-definition&#34;&gt;3.1. Formal Problem Definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A graph $G = (V, E)$ : represents the map of the city.&lt;/li&gt;
&lt;li&gt;A set $N= \{ 1,2,\cdots,n \}$ : reprensents $n$ taxis requests.&lt;/li&gt;
&lt;li&gt;A set $K = \{ 2n + 1, \cdots, 2n+ta \}$ : represents $ta$ taxi vehicles.&lt;/li&gt;
&lt;li&gt;Each request $i \in N$ has a source point $i$ , a destination point $i + n$ , an earliest departure time $e_{i}$ , a latest arrival time $l_{i}$ and the number of people $p_{i}$ .&lt;/li&gt;
&lt;li&gt;Each taxi vehicle $k \in K$ has a source point $k$ , the vehicle capacity $ca_{k}$ , the start time $e_{k}$ and the end time $l_{k}$ .&lt;/li&gt;
&lt;li&gt;Every pair of vertices $i,j$ has the travel time $t_{ij}$ and the travel cost $c_{ij}$ .&lt;/li&gt;
&lt;li&gt;A taxi route is defined as a sequence of pickup and delivery points.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-objective-function&#34;&gt;3.2. Objective Function&lt;/h3&gt;
&lt;p&gt;$$ \max \sum_{k \in K} \sum_{i \in N} x_{i}^{k} - \alpha \cfrac{C_{i}^{k}}{C_{i,i+n}} $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$x_{i}^{k}$ : 0 or 1, represents request $i$ is or not served by vehicle $k$ .&lt;/li&gt;
&lt;li&gt;$C_{i}^{k}$ : represents the cost payed by the request $i$ served by vehicle $k$ .&lt;/li&gt;
&lt;li&gt;$C_{i, i+n}$ : represents the cost of a private trip for request $i$ .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-time-processing&#34;&gt;4.1. Time Processing&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;This paper divides the day into a set of short time periods.&lt;/li&gt;
&lt;li&gt;In each period it solves a static version of the problem using the GRASP heuristic, taking into account all known requests and vehicles.&lt;/li&gt;
&lt;li&gt;The requests that were not served are added in the input of the next execution.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-the-grasp-heuristic&#34;&gt;4.2. The GRASP Heuristic&lt;/h3&gt;
&lt;p&gt;The paper proposes a greedy randomized adaptive search procedure (GRASP) to solve the static version of the TSTWP.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In the first phase we have to &lt;strong&gt;compute a greedy randomized initial solution&lt;/strong&gt;. The greedy strategy leads to good solutions and randomization is used so that different initial solutions can be constructed.&lt;/li&gt;
&lt;li&gt;In the second phase, &lt;strong&gt;a local search&lt;/strong&gt; is performed in order to improve the solution found in the first phase. The GRASP metaheuristic repeats these two phases for a maximum number of iterations (or a maximum time).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-computing-initial-solutions&#34;&gt;4.3. Computing Initial Solutions&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;First of all, we initialize the route of each taxi.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add the source point $k$ of each taxi as the first point of its route&lt;/li&gt;
&lt;li&gt;set $T_{k}^{k}$ as the maximum between $e_{k}$ and the time at the moment&lt;/li&gt;
&lt;li&gt;set $L_{k}^{k} = 0$,  because the taxi driver is not counted as a passenger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the case that some taxis may already have a route,  we update and copy its route.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A random taxi $k$ is chosen from $K$ . Then, for all requests $i \in N$ that were not served yet, we calculate a &lt;strong&gt;greedy function&lt;/strong&gt; $\mu_{i}^{k}$  . After that, a request $i$ is chosen randomly with probability proportional to $\mu_{i}^{k}$ .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We try to insert the source and destination points of the request $i$ in the route of the taxi $k$ .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the insertion is feasible, we remove this request from $N$, and we update the greedy function for all remaining unserved requests in $N$ .&lt;/li&gt;
&lt;li&gt;If the insertion is unfeasible we do not try to insert this request anymore in the route of this taxi.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then, another request is chosen in the same manner. After we tried to insert all requests, we remove $k$ from $K$ and the procedure is repeated, until $K = \emptyset $ .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;44-greedy-function&#34;&gt;4.4. Greedy Function&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Delay Time&lt;/strong&gt; : We define the delay time $d_{j,i}^{k}$ of a point $i$ as the amount of time that would be increased if point $i$ had been inserted after point $j$ , in the route of taxi $k$ .&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$$d_{i,j}^{k} = \max \{ t_{ji}, e_{i}-T_{j}^{k} \}$$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-5-1/method_1_hu220c0b7ca3c140e44d1a186d0012b155_29481_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-5-1/method_1_hu220c0b7ca3c140e44d1a186d0012b155_29481_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;516&#34; height=&#34;181&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$$ d_{j,i+n}^{k} = \begin{cases} t_{j,i+n}, \text{ if } t_{j,i+n}+T_{j}^{k}\leq l_{i} \\  \infty , \text{ otherwise} \end{cases}$$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Greedy Function&lt;/strong&gt; : $ \mu_{i}^{k} = \min_{j \in R(k)}d_{j,i}^{k} + \min_{j \in R(k)}d_{j,i+n}^{k} $&lt;/p&gt;
&lt;h3 id=&#34;45-local-search&#34;&gt;4.5. Local Search&lt;/h3&gt;
&lt;p&gt;The local search method starts setting as the current solution an initial feasible solution, and explore new feasible solutions that are in its neighborhood. Three types of operations are proposed to obtain new solutions.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Removal of some request from some route and attempt to insert, in this route, some request that was not served.&lt;/li&gt;
&lt;li&gt;Permutation of two requests from different routes.&lt;/li&gt;
&lt;li&gt;Permutation of two consecutive points of the same route.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;At each iteration, we perform each of the three operations defined above, obtaining three new solutions. If the best of them is better than the current one, then the method sets this solution as the new current one. This procedure is repeated until there is no improvement in the current solution after a certain number of consecutive iterations, or until some maximum number of iterations is achieved.&lt;/p&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;p&gt;No contributions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Note - 2020/2/4</title>
      <link>/post/2020-2-4-1/</link>
      <pubDate>Tue, 04 Feb 2020 13:10:41 +0800</pubDate>
      <guid>/post/2020-2-4-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;There are three types of participants in the scenario: organization, drivers and passengers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Organization&lt;/strong&gt; : Organization is a company or a transportation authority that operates a dynamic taxi ridesharing service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Drivers&lt;/strong&gt; : Taxi drivers can independently determine when to join and leave the service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Passengers&lt;/strong&gt; : Passengers submit ride queries in real time via a mobile device&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each query indicates the &lt;u&gt;origin and destination locations of the trip&lt;/u&gt;, as well as &lt;u&gt;time windows constraining when the passenger wants to be picked up and dropped off&lt;/u&gt;.&lt;/p&gt;
&lt;p&gt;Once receiving a new query, the organization will dispatch an &amp;ldquo;appropriate&amp;rdquo; taxi which is able to satisfy both the new query and the trips of existing passengers who are already assigned to the taxi.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper propose a two-fold goal.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The first goal&lt;/strong&gt; is to investigate the potential of taxi ridesharing in serving more taxi ride queries by comparing with the case where no ridesharing is conducted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second goal&lt;/strong&gt; is to reduce the total travel distance of these taxis (so as to reduce the energy consumption) when doing the ridesharing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the problem is to build a dynamic ridesharing service applicable for the practical use, i.e. serving a large number of queries quickly. &lt;u&gt;To achieve this purpose, two issues need to be addressed.&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The first issue&lt;/strong&gt; : How to quickly search an &amp;ldquo;appropriate&amp;rdquo; taxi from a large number of candidate cars?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second issue&lt;/strong&gt; : How to accelerate the computation of shortest paths since the shortest path calculation is usually complicated?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-definition&#34;&gt;3.1. Definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Query&lt;/strong&gt; : A query Q is a passenger’s request for a taxi ride.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/query_hud347ee22c158084d84b8812f6b857e6a_9338_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/query_hud347ee22c158084d84b8812f6b857e6a_9338_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;481&#34; height=&#34;81&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Schedule&lt;/strong&gt; : A schedule S is a temporally-ordered sequence of pickup and delivery points.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/schedule_hu47c934b410a1689cc18669ba9768b129_5600_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/schedule_hu47c934b410a1689cc18669ba9768b129_5600_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;221&#34; height=&#34;101&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Taxi Status&lt;/strong&gt; :  A taxi status V represents the instantaneous state of a taxi.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/taxi_status_hu6418551d827abec3032b98b822b04033_16114_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/taxi_status_hu6418551d827abec3032b98b822b04033_16114_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;840&#34; height=&#34;131&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Satisfaction&lt;/strong&gt; : Given a taxi status V and a query Q, the paper says that V satisfies Q iff
&lt;ol&gt;
&lt;li&gt;The number of on-board passengers is smaller than the capacity of the taxi.&lt;/li&gt;
&lt;li&gt;The taxi can pickup and drop off Q and other on-board passengers without violating the time constraint.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-problem&#34;&gt;3.2. Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The Dynamic Taxi Ridesharing Problem&lt;/strong&gt; : Given a fixed number of taxis traveling on a road network and a stream of queries (i.e. a sequence of queries in ascending order of their birth time), the paper aims to &lt;u&gt;serve each query in the stream by dispatching the taxi which satisfies with minimum additional incurred travel distance on the road network&lt;/u&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; The paper aims to minimize the increased travel distance for each individual query. This is obviously a greedy strategy and it does not guarantee that the total travel distance of all taxis for all queries is minimized. &lt;u&gt;Howerver, the problem of optimizing travel distance for all taxis for the whole query stream has been proved to be NP-complete by reducing to the Travelling Salesman Problem with Time Window.&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-framework&#34;&gt;3.3. Framework&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/framework_hu80a8d6d7f84148f102c61f3aba0566fb_75147_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/framework_hu80a8d6d7f84148f102c61f3aba0566fb_75147_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;513&#34; height=&#34;459&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-a-spatio-temporal-index-of-taxis&#34;&gt;4.1. A Spatio-temporal Index of Taxis&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : It needs to use the query’s time windows to filter out unsatisfactory taxis. The authors want a taxi searching process that is both fast and selects taxis wisely such that the selected taxis can satisfy the query with a reasonable small increase in travel distance over their existing schedules. If we use a pre-computed distance to approximate the distance of the shortest path, though the distance is not exact anymore, the time-consuming problem completely goes away.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We partition the road network using a grid. Within each grid cell, we choose the road network node which is closest to the geographical centre of the cell as the anchor node of the cell. The anchor node of a grid cell $g_{i}$ is thereafter denoted by $c_{i}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_1_huf29fbc3cd8f55bc41b1972a0aa4ee356_31851_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_1_huf29fbc3cd8f55bc41b1972a0aa4ee356_31851_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;321&#34; height=&#34;312&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We pre-compute the distance, denoted by $d_{ij}$ , and travel time, denoted by $t_{ij}$ , of the shortest path on the road network for each anchor node pair $c_{i}$ and $c_{j}$ . The distance and travel time results are saved in a matrix. The matrix is thereafter referred to as the grid distance matrix.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_2_huc544431513aa519ce59bb06262b6fd41_25966_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_2_huc544431513aa519ce59bb06262b6fd41_25966_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;366&#34; height=&#34;315&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Now imagine that each grid cell collapses to its anchor node, that is, all the points in one cell fall to its anchor node. Then the distance between any two arbitrary points equals to the distance between two corresponding anchor nodes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each cell has some internal data structure for the purpose of taxi searching. Specifically, each grid cell $g_{i}$ maintains three lists: a temporally-ordered grid cell list $(g_{i}.l_{g}^{t})$ , a spatially-ordered grid cell list $(g_{i}.l_{g}^{d})$ , and a taxi list $(g_{i}.l_{v})$ . The spatial and temporal closeness between each pair of grid cells are measured by the values saved in the grid distance matrix.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_3_hu2d038ac018bc8d992497e2484a0723fd_26837_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_3_hu2d038ac018bc8d992497e2484a0723fd_26837_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;520&#34; height=&#34;299&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each taxi ID is also tagged with a timestamp $t_{a}$ indicating when the taxi will enter the grid cell. Specifically, taxi $V_{j}$ is removed from the list when $V_{j}$ leaves $g_{i}$ ; taxi $V_{k}$ is inserted into the list when $V_{j}$ is newly scheduled to enter $g_{i}$ .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-taxi-searching-algorithms&#34;&gt;4.2. Taxi Searching Algorithms&lt;/h3&gt;
&lt;h4 id=&#34;421-single-side-taxi-searching&#34;&gt;4.2.1. Single-side Taxi Searching&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : We use query&amp;rsquo;s late pick-up timestamp to filter out grids, then filter the possible taxis from the candidate grids.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Suppose a passenger commits a query $Q$ located at grid $g_{7}$ at the time of $t_{cur}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_1_hu7d7e326b5cd973f956622b15ceb057ed_98800_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_1_hu7d7e326b5cd973f956622b15ceb057ed_98800_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;638&#34; height=&#34;387&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Any other arbitrary grid cell is selected by the searching algorithm if and only if
$$t_{i7} + t_{cur} \leq Q.wp.l$$
$t_{i7}$ indicates the travel time from grid $g_{i}$ to grid $g_{7}$ . To quickly find all grids hold the equation above, the single-side searching algorithm simply tests all grid cells in the order-preserved list $g_{7}.l_{g}^{t}$ and finds the first grid $g_{f}$ fails to hold the equation. Then the grids before $g_{f}$  in the list $g_{7}.l_{g}^{t}$ are selected as candidate taxis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For  each selected grid cell $g_{s}$ , the algorithm selects taxis (in $g_{s}.l_{v}$) whose $t_{a}$ is no later than $Q.wp.l - t_{s7}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_2_hub75161ce21867257f31b85020308e40b_30416_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_2_hub75161ce21867257f31b85020308e40b_30416_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;589&#34; height=&#34;249&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Weakness&lt;/strong&gt; : Unfortunately, this algorithm only considers taxis currently &amp;ldquo;near&amp;rdquo; the pickup point of a query (thus called single-side search). As the number of selected grid cells could be large, this algorithm may result in many taxis retrieved for the later scheduling module (therefore increasing the entire computation cost).&lt;/p&gt;
&lt;h4 id=&#34;422-dual-side-taxi-searching&#34;&gt;4.2.2. Dual-Side Taxi Searching&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : The spatio-temporal factor on the delivery point of queries also provides us with opportunities to reduce the number of grid cells to be selected. A dual-side searching algorithm is proposed as an effort for striking a balance between the distance optimality and the computation cost.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Suppose the deliver point is at grid $g_{2}$ . Any grid cell $g_{j}$ other than $g_{2}$ is selected by the searching algorithm at side if and only if the equation below holds, which means that any taxi currently in can enter before the late bound of the delivery window.
$$t_{cur}+t_{j2} \leq Q.wd.l$$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_3_hu31892b81786e77bcee49283119a63262_101906_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_3_hu31892b81786e77bcee49283119a63262_101906_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;665&#34; height=&#34;376&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The algorithm mantains a set $S_{o}$ and a set $S_{d}$ to store the taxis selected from $Q.o$ and $Q.d$ side respectively.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Initially, both and are empty.&lt;/li&gt;
&lt;li&gt;The first step in the searching is to add the taxis selected from taxi list $g_{7}.l_{v}$ to set $S_{o}$ , and add the taxis selected from taxi list $g_{2}.l_{v}$ to set $S_{d}$ . Then the algorithm calculates the intersection of $S_{o}$ and $S_{d}$ .&lt;/li&gt;
&lt;li&gt;If the intersection is not empty, the algorithm stops immediately and returns the intersection set. Otherwise, it expands the searching area by including one other grid cell at each side at a time.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_4_hua22a83df82277672b1b2b72fdfd73af6_110070_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_4_hua22a83df82277672b1b2b72fdfd73af6_110070_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;640&#34; height=&#34;625&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-scheduling-module&#34;&gt;4.3. Scheduling Module&lt;/h3&gt;
&lt;h4 id=&#34;431-insertion-feasibility-check&#34;&gt;4.3.1. Insertion Feasibility Check&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The insertion can be separated into two stages: (i) insert the pickup point of the query $Q.o$ ; (ii) insert the delivery point of the query $Q.d$ . Among all possible ways of insertion, the system chooses the insertion way that minimally increases the travel distance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An insertion feasibility check is done before an insertion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The passenger should be picked up before $Q.wp.l$ .&lt;/li&gt;
&lt;li&gt;Travel time delay $t_{d}$ should not result the late arrival at any point after the insertion.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The increased travel distance is calculated when both $Q.o$ and $Q.d$ are inserted successfully.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_3_1_hu943817b818205cb3f2c05fa79d2c2b07_37963_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_3_1_hu943817b818205cb3f2c05fa79d2c2b07_37963_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;672&#34; height=&#34;186&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;432-lazy-shortest-path-calculation-strategy&#34;&gt;4.3.2. Lazy Shortest Path Calculation Strategy&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : The paper aims to expedite the insertion process by speeding up the calculation itself instead of eliminating some insertion possibilities.&lt;/p&gt;
&lt;p&gt;The calculation of shortest path is deferred or avoided by the following logic:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the shortest path between the origin location O and the destination location D has been previously calculated, then the algorithm simply retrieves the path from the cached results.&lt;/li&gt;
&lt;li&gt;Otherwise, instead of directly calculating the shortest path, the algorithm first calculates the lower bound of the travel time between O and D using the precomputed travel time between grid cells and the triangle inequality. Only when the lower bound does not violate time constraints, the algorithm needs to proceed to compute the shortest-time path between points O and D.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is evident that the grid size will affect the effectiveness of lazy shortest path calculation strategy. State-of-art shortest path algorithms can be applied to speed up on-line shortest path calculations.&lt;/p&gt;
&lt;h2 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Measurements
&lt;ol&gt;
&lt;li&gt;Relative Distance Rate (RDR) : Define the distance of a query $Q$ as the distance between its pickup point $Q.o$ and its delivery point $Q.d$ . Denote by $D_{SQ}$ the sum of distances of queries that get satisfied and by $D_{V}$ the total distance travelled by all taxis in the ridesharing.
$$RDR = D_{V}/D_{SQ}$$&lt;/li&gt;
&lt;li&gt;Satisfaction Rate (SR) : is the fraction of queries get satisfied in the ridesharing (exclude queries that are already served by taxis at the initial state in the query counting).&lt;/li&gt;
&lt;li&gt;Number of Road Nodes Accessed Per Query (#RNAPQ) : is the number of accessed road network nodes per query.&lt;/li&gt;
&lt;li&gt;Number of Grid Cells Accessed Per Query (#GCAPQ) : is the number of accessed grid cells per query.&lt;/li&gt;
&lt;li&gt;Number of Taxis Accessed Per Query (#TAPQ) : This measurement records how many taxis per query are accessed for insertion feasibility checks by the scheduling module.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
