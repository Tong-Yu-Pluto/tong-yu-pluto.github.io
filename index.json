[{"authors":["admin"],"categories":null,"content":"OTAKU~\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"OTAKU~","tags":null,"title":"Tong Yu","type":"authors"},{"authors":["Tong Yu"],"categories":["Paper Note - PVLDB"],"content":"1. Scenario 2. Motivation 3. Preliminaries 4. Method 5. Experiment ","date":1581053107,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581053107,"objectID":"689857f4defdc677e5532287bd916843","permalink":"/post/2020-2-7-1/","publishdate":"2020-02-07T13:25:07+08:00","relpermalink":"/post/2020-2-7-1/","section":"post","summary":"(PVLDB 2014) Large Scale Real-time Ridesharing with Service Guarantee on Road Networks.","tags":["ridesharing","spatial crowdsourcing"],"title":"Paper Note - 2020/2/7","type":"post"},{"authors":["Tong Yu"],"categories":["Paper Note - IJCAI"],"content":"1. Scenario  Passenger : A person uses the cell app (or a regular phone call to a taxi company) specifying its current location, destination, and others informations such as a maximum delay that he is available to accept (the delay is in comparison with a sole taxi trip). Driver : Car owners and riders specify their origins and destinations. Car owners also indicate a maximum delay they can accept. Plateform : If a user gets a shared trip, the system must guarantee that it is cheaper than the trip where he goes alone, and that he arrives at his destination within the maximum delay specified. Based on the car gas price and consumption per kilometer, the system computes matchings between car owners and riders.  2. Motivation This paper focuses principally on the optimization problem that we call dynamic taxi sharing with time windows problem (TSTWP).\nSeveral constraints must be considered:\n the vehicle capacity the cost of a shared ride must not exceed the cost of a private ride each passenger and taxi has time window  This paper wants to maximize the number of served requests and minimize the total cost incurred to passengers, which is the same as maximize the sharing. The goals are:\n The first goal : Maximize the number of served requests. The second goal : Minimize the cost payed by the served passengers.  P.S. There is an upper bound for the second objective, by computing the cost of each trip as a private trip.\nThe hard part is\n Time : No one can arrive at its destination later than its maximum allowable time, and no one is served before its service time. Costs : A taxi passenger on a shared trip can not spend more money than on a sole trip. A car owner interested in offering rides, must receive at least as much he spend doing an alternative route, instead of his shortest path route. Safety : The system used by hitchhikers and car owners requires a previous registration. Users can specify that they only ride with friends of friends for example, using data from social networks.  3. Preliminaries 3.1. Formal Problem Definition  A graph $G = (V, E)$ : represents the map of the city. A set $N= \\{ 1,2,\\cdots,n \\}$ : reprensents $n$ taxis requests. A set $K = \\{ 2n + 1, \\cdots, 2n+ta \\}$ : represents $ta$ taxi vehicles. Each request $i \\in N$ has a source point $i$ , a destination point $i + n$ , an earliest departure time $e_{i}$ , a latest arrival time $l_{i}$ and the number of people $p_{i}$ . Each taxi vehicle $k \\in K$ has a source point $k$ , the vehicle capacity $ca_{k}$ , the start time $e_{k}$ and the end time $l_{k}$ . Every pair of vertices $i,j$ has the travel time $t_{ij}$ and the travel cost $c_{ij}$ . A taxi route is defined as a sequence of pickup and delivery points.  3.2. Objective Function $$ \\max \\sum_{k \\in K} \\sum_{i \\in N} x_{i}^{k} - \\alpha \\cfrac{C_{i}^{k}}{C_{i,i+n}} $$\n $x_{i}^{k}$ : 0 or 1, represents request $i$ is or not served by vehicle $k$ . $C_{i}^{k}$ : represents the cost payed by the request $i$ served by vehicle $k$ . $C_{i, i+n}$ : represents the cost of a private trip for request $i$ .  4. Method 4.1. Time Processing  This paper divides the day into a set of short time periods. In each period it solves a static version of the problem using the GRASP heuristic, taking into account all known requests and vehicles. The requests that were not served are added in the input of the next execution.  4.2. The GRASP Heuristic The paper proposes a greedy randomized adaptive search procedure (GRASP) to solve the static version of the TSTWP.\n In the first phase we have to compute a greedy randomized initial solution. The greedy strategy leads to good solutions and randomization is used so that different initial solutions can be constructed. In the second phase, a local search is performed in order to improve the solution found in the first phase. The GRASP metaheuristic repeats these two phases for a maximum number of iterations (or a maximum time).  4.3. Computing Initial Solutions   First of all, we initialize the route of each taxi.\n add the source point $k$ of each taxi as the first point of its route set $T_{k}^{k}$ as the maximum between $e_{k}$ and the time at the moment set $L_{k}^{k} = 0$, because the taxi driver is not counted as a passenger    In the case that some taxis may already have a route, we update and copy its route.\n  A random taxi $k$ is chosen from $K$ . Then, for all requests $i \\in N$ that were not served yet, we calculate a greedy function $\\mu_{i}^{k}$ . After that, a request $i$ is chosen randomly with probability proportional to $\\mu_{i}^{k}$ .\n  We try to insert the source and destination points of the request $i$ in the route of the taxi $k$ .\n If the insertion is feasible, we remove this request from $N$, and we update the greedy function for all remaining unserved requests in $N$ . If the insertion is unfeasible we do not try to insert this request anymore in the route of this taxi.    Then, another request is chosen in the same manner. After we tried to insert all requests, we remove $k$ from $K$ and the procedure is repeated, until $K = \\emptyset $ .\n  4.4. Greedy Function Delay Time : We define the delay time $d_{j,i}^{k}$ of a point $i$ as the amount of time that would be increased if point $i$ had been inserted after point $j$ , in the route of taxi $k$ .\n  $$d_{i,j}^{k} = \\max \\{ t_{ji}, e_{i}-T_{j}^{k} \\}$$      $$ d_{j,i+n}^{k} = \\begin{cases} t_{j,i+n}, \\text{ if } t_{j,i+n}+T_{j}^{k}\\leq l_{i} \\\\ \\infty , \\text{ otherwise} \\end{cases}$$\n  Greedy Function : $ \\mu_{i}^{k} = \\min_{j \\in R(k)}d_{j,i}^{k} + \\min_{j \\in R(k)}d_{j,i+n}^{k} $\n4.5. Local Search The local search method starts setting as the current solution an initial feasible solution, and explore new feasible solutions that are in its neighborhood. Three types of operations are proposed to obtain new solutions.\n Removal of some request from some route and attempt to insert, in this route, some request that was not served. Permutation of two requests from different routes. Permutation of two consecutive points of the same route.  At each iteration, we perform each of the three operations defined above, obtaining three new solutions. If the best of them is better than the current one, then the method sets this solution as the new current one. This procedure is repeated until there is no improvement in the current solution after a certain number of consecutive iterations, or until some maximum number of iterations is achieved.\n5. Experiment No contributions.\n","date":1580902480,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580902480,"objectID":"b7b805a6fca252aae76377d2ace5dc89","permalink":"/post/2020-2-5-1/","publishdate":"2020-02-05T19:34:40+08:00","relpermalink":"/post/2020-2-5-1/","section":"post","summary":"(IJCAI 2013) Dynamic Taxi and Ridesharing: A Framework and Heuristics for the Optimization Problem.","tags":["ridesharing","spatial crowdsourcing"],"title":"Paper Note - 2020/2/5","type":"post"},{"authors":["Tong Yu"],"categories":["Paper Note - ICDE"],"content":"1. Scenario There are three types of participants in the scenario: organization, drivers and passengers.\n Organization : Organization is a company or a transportation authority that operates a dynamic taxi ridesharing service. Drivers : Taxi drivers can independently determine when to join and leave the service. Passengers : Passengers submit ride queries in real time via a mobile device  Each query indicates the origin and destination locations of the trip, as well as time windows constraining when the passenger wants to be picked up and dropped off.\nOnce receiving a new query, the organization will dispatch an \u0026ldquo;appropriate\u0026rdquo; taxi which is able to satisfy both the new query and the trips of existing passengers who are already assigned to the taxi.\n2. Motivation This paper propose a two-fold goal.\n The first goal is to investigate the potential of taxi ridesharing in serving more taxi ride queries by comparing with the case where no ridesharing is conducted. The second goal is to reduce the total travel distance of these taxis (so as to reduce the energy consumption) when doing the ridesharing.  So the problem is to build a dynamic ridesharing service applicable for the practical use, i.e. serving a large number of queries quickly. To achieve this purpose, two issues need to be addressed.\n The first issue : How to quickly search an \u0026ldquo;appropriate\u0026rdquo; taxi from a large number of candidate cars? The second issue : How to accelerate the computation of shortest paths since the shortest path calculation is usually complicated?  3. Preliminaries 3.1. Definition  Query : A query Q is a passengerâ€™s request for a taxi ride.     Schedule : A schedule S is a temporally-ordered sequence of pickup and delivery points.     Taxi Status : A taxi status V represents the instantaneous state of a taxi.     Satisfaction : Given a taxi status V and a query Q, the paper says that V satisfies Q iff  The number of on-board passengers is smaller than the capacity of the taxi. The taxi can pickup and drop off Q and other on-board passengers without violating the time constraint.    3.2. Problem   The Dynamic Taxi Ridesharing Problem : Given a fixed number of taxis traveling on a road network and a stream of queries (i.e. a sequence of queries in ascending order of their birth time), the paper aims to serve each query in the stream by dispatching the taxi which satisfies with minimum additional incurred travel distance on the road network.\n  P.S. The paper aims to minimize the increased travel distance for each individual query. This is obviously a greedy strategy and it does not guarantee that the total travel distance of all taxis for all queries is minimized. Howerver, the problem of optimizing travel distance for all taxis for the whole query stream has been proved to be NP-complete by reducing to the Travelling Salesman Problem with Time Window.\n  3.3. Framework    4. Method 4.1. A Spatio-temporal Index of Taxis Main Idea : It needs to use the queryâ€™s time windows to filter out unsatisfactory taxis. The authors want a taxi searching process that is both fast and selects taxis wisely such that the selected taxis can satisfy the query with a reasonable small increase in travel distance over their existing schedules. If we use a pre-computed distance to approximate the distance of the shortest path, though the distance is not exact anymore, the time-consuming problem completely goes away.\n  We partition the road network using a grid. Within each grid cell, we choose the road network node which is closest to the geographical centre of the cell as the anchor node of the cell. The anchor node of a grid cell $g_{i}$ is thereafter denoted by $c_{i}$ .      We pre-compute the distance, denoted by $d_{ij}$ , and travel time, denoted by $t_{ij}$ , of the shortest path on the road network for each anchor node pair $c_{i}$ and $c_{j}$ . The distance and travel time results are saved in a matrix. The matrix is thereafter referred to as the grid distance matrix.      Now imagine that each grid cell collapses to its anchor node, that is, all the points in one cell fall to its anchor node. Then the distance between any two arbitrary points equals to the distance between two corresponding anchor nodes.\n  Each cell has some internal data structure for the purpose of taxi searching. Specifically, each grid cell $g_{i}$ maintains three lists: a temporally-ordered grid cell list $(g_{i}.l_{g}^{t})$ , a spatially-ordered grid cell list $(g_{i}.l_{g}^{d})$ , and a taxi list $(g_{i}.l_{v})$ . The spatial and temporal closeness between each pair of grid cells are measured by the values saved in the grid distance matrix.      Each taxi ID is also tagged with a timestamp $t_{a}$ indicating when the taxi will enter the grid cell. Specifically, taxi $V_{j}$ is removed from the list when $V_{j}$ leaves $g_{i}$ ; taxi $V_{k}$ is inserted into the list when $V_{j}$ is newly scheduled to enter $g_{i}$ .\n  4.2. Taxi Searching Algorithms 4.2.1. Single-side Taxi Searching Main Idea : We use query\u0026rsquo;s late pick-up timestamp to filter out grids, then filter the possible taxis from the candidate grids.\n  Suppose a passenger commits a query $Q$ located at grid $g_{7}$ at the time of $t_{cur}$ .      Any other arbitrary grid cell is selected by the searching algorithm if and only if $$t_{i7} + t_{cur} \\leq Q.wp.l$$ $t_{i7}$ indicates the travel time from grid $g_{i}$ to grid $g_{7}$ . To quickly find all grids hold the equation above, the single-side searching algorithm simply tests all grid cells in the order-preserved list $g_{7}.l_{g}^{t}$ and finds the first grid $g_{f}$ fails to hold the equation. Then the grids before $g_{f}$ in the list $g_{7}.l_{g}^{t}$ are selected as candidate taxis.\n  For each selected grid cell $g_{s}$ , the algorithm selects taxis (in $g_{s}.l_{v}$) whose $t_{a}$ is no later than $Q.wp.l - t_{s7}$ .      Weakness : Unfortunately, this algorithm only considers taxis currently \u0026ldquo;near\u0026rdquo; the pickup point of a query (thus called single-side search). As the number of selected grid cells could be large, this algorithm may result in many taxis retrieved for the later scheduling module (therefore increasing the entire computation cost).\n4.2.2. Dual-Side Taxi Searching Main Idea : The spatio-temporal factor on the delivery point of queries also provides us with opportunities to reduce the number of grid cells to be selected. A dual-side searching algorithm is proposed as an effort for striking a balance between the distance optimality and the computation cost.\n  Suppose the deliver point is at grid $g_{2}$ . Any grid cell $g_{j}$ other than $g_{2}$ is selected by the searching algorithm at side if and only if the equation below holds, which means that any taxi currently in can enter before the late bound of the delivery window. $$t_{cur}+t_{j2} \\leq Q.wd.l$$      The algorithm mantains a set $S_{o}$ and a set $S_{d}$ to store the taxis selected from $Q.o$ and $Q.d$ side respectively.\n Initially, both and are empty. The first step in the searching is to add the taxis selected from taxi list $g_{7}.l_{v}$ to set $S_{o}$ , and add the taxis selected from taxi list $g_{2}.l_{v}$ to set $S_{d}$ . Then the algorithm calculates the intersection of $S_{o}$ and $S_{d}$ . If the intersection is not empty, the algorithm stops immediately and returns the intersection set. Otherwise, it expands the searching area by including one other grid cell at each side at a time.        4.3. Scheduling Module 4.3.1. Insertion Feasibility Check   The insertion can be separated into two stages: (i) insert the pickup point of the query $Q.o$ ; (ii) insert the delivery point of the query $Q.d$ . Among all possible ways of insertion, the system chooses the insertion way that minimally increases the travel distance.\n  An insertion feasibility check is done before an insertion:\n The passenger should be picked up before $Q.wp.l$ . Travel time delay $t_{d}$ should not result the late arrival at any point after the insertion.    The increased travel distance is calculated when both $Q.o$ and $Q.d$ are inserted successfully.      4.3.2. Lazy Shortest Path Calculation Strategy Main Idea : The paper aims to expedite the insertion process by speeding up the calculation itself instead of eliminating some insertion possibilities.\nThe calculation of shortest path is deferred or avoided by the following logic:\n If the shortest path between the origin location O and the destination location D has been previously calculated, then the algorithm simply retrieves the path from the cached results. Otherwise, instead of directly calculating the shortest path, the algorithm first calculates the lower bound of the travel time between O and D using the precomputed travel time between grid cells and the triangle inequality. Only when the lower bound does not violate time constraints, the algorithm needs to proceed to compute the shortest-time path between points O and D.  It is evident that the grid size will affect the effectiveness of lazy shortest path calculation strategy. State-of-art shortest path algorithms can be applied to speed up on-line shortest path calculations.\n5. Experiment  Measurements  Relative Distance Rate (RDR) : Define the distance of a query $Q$ as the distance between its pickup point $Q.o$ and its delivery point $Q.d$ . Denote by $D_{SQ}$ the sum of distances of queries that get satisfied and by $D_{V}$ the total distance travelled by all taxis in the ridesharing. $$RDR = D_{V}/D_{SQ}$$ Satisfaction Rate (SR) : is the fraction of queries get satisfied in the ridesharing (exclude queries that are already served by taxis at the initial state in the query counting). Number of Road Nodes Accessed Per Query (#RNAPQ) : is the number of accessed road network nodes per query. Number of Grid Cells Accessed Per Query (#GCAPQ) : is the number of accessed grid cells per query. Number of Taxis Accessed Per Query (#TAPQ) : This measurement records how many taxis per query are accessed for insertion feasibility checks by the scheduling module.    ","date":1580793041,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580793041,"objectID":"9b75f0a4f720df2da9e9580e93f7c4c5","permalink":"/post/2020-2-4-1/","publishdate":"2020-02-04T13:10:41+08:00","relpermalink":"/post/2020-2-4-1/","section":"post","summary":"(ICDE 2013) T-Share: A Large-Scale Dynamic Taxi Ridesharing Service.","tags":["ridesharing","spatial crowdsourcing"],"title":"Paper Note - 2020/2/4","type":"post"}]