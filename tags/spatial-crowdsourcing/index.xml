<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spatial crowdsourcing | Tong Yu</title>
    <link>/tags/spatial-crowdsourcing/</link>
      <atom:link href="/tags/spatial-crowdsourcing/index.xml" rel="self" type="application/rss+xml" />
    <description>spatial crowdsourcing</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 04 Feb 2020 13:10:41 +0800</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>spatial crowdsourcing</title>
      <link>/tags/spatial-crowdsourcing/</link>
    </image>
    
    <item>
      <title>Paper Note - 2020/2/4</title>
      <link>/post/2020-2-4-1/</link>
      <pubDate>Tue, 04 Feb 2020 13:10:41 +0800</pubDate>
      <guid>/post/2020-2-4-1/</guid>
      <description>&lt;h2 id=&#34;1-scenario&#34;&gt;1. Scenario&lt;/h2&gt;
&lt;p&gt;There are three types of participants in the scenario: organization, drivers and passengers.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Organization&lt;/strong&gt; : Organization is a company or a transportation authority that operates a dynamic taxi ridesharing service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Drivers&lt;/strong&gt; : Taxi drivers can independently determine when to join and leave the service.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Passengers&lt;/strong&gt; : Passengers submit ride queries in real time via a mobile device&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each query indicates the &lt;u&gt;origin and destination locations of the trip&lt;/u&gt;, as well as &lt;u&gt;time windows constraining when the passenger wants to be picked up and dropped off&lt;/u&gt;.&lt;/p&gt;
&lt;p&gt;Once receiving a new query, the organization will dispatch an &amp;ldquo;appropriate&amp;rdquo; taxi which is able to satisfy both the new query and the trips of existing passengers who are already assigned to the taxi.&lt;/p&gt;
&lt;h2 id=&#34;2-motivation&#34;&gt;2. Motivation&lt;/h2&gt;
&lt;p&gt;This paper propose a two-fold goal.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The first goal&lt;/strong&gt; is to investigate the potential of taxi ridesharing in serving more taxi ride queries by comparing with the case where no ridesharing is conducted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second goal&lt;/strong&gt; is to reduce the total travel distance of these taxis (so as to reduce the energy consumption) when doing the ridesharing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the problem is to build a dynamic ridesharing service applicable for the practical use, i.e. serving a large number of queries quickly. &lt;u&gt;To achieve this purpose, two issues need to be addressed.&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The first issue&lt;/strong&gt; : How to quickly search an &amp;ldquo;appropriate&amp;rdquo; taxi from a large number of candidate cars?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The second issue&lt;/strong&gt; : How to accelerate the computation of shortest paths since the shortest path calculation is usually complicated?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-preliminaries&#34;&gt;3. Preliminaries&lt;/h2&gt;
&lt;h3 id=&#34;31-definition&#34;&gt;3.1. Definition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Query&lt;/strong&gt; : A query Q is a passenger’s request for a taxi ride.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/query_hud347ee22c158084d84b8812f6b857e6a_9338_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/query_hud347ee22c158084d84b8812f6b857e6a_9338_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;481&#34; height=&#34;81&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Schedule&lt;/strong&gt; : A schedule S is a temporally-ordered sequence of pickup and delivery points.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/schedule_hu47c934b410a1689cc18669ba9768b129_5600_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/schedule_hu47c934b410a1689cc18669ba9768b129_5600_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;221&#34; height=&#34;101&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Taxi Status&lt;/strong&gt; :  A taxi status V represents the instantaneous state of a taxi.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/taxi_status_hu6418551d827abec3032b98b822b04033_16114_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/taxi_status_hu6418551d827abec3032b98b822b04033_16114_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;840&#34; height=&#34;131&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Satisfaction&lt;/strong&gt; : Given a taxi status V and a query Q, the paper says that V satisfies Q iff
&lt;ol&gt;
&lt;li&gt;The number of on-board passengers is smaller than the capacity of the taxi.&lt;/li&gt;
&lt;li&gt;The taxi can pickup and drop off Q and other on-board passengers without violating the time constraint.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-problem&#34;&gt;3.2. Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The Dynamic Taxi Ridesharing Problem&lt;/strong&gt; : Given a fixed number of taxis traveling on a road network and a stream of queries (i.e. a sequence of queries in ascending order of their birth time), the paper aims to &lt;u&gt;serve each query in the stream by dispatching the taxi which satisfies with minimum additional incurred travel distance on the road network&lt;/u&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; The paper aims to minimize the increased travel distance for each individual query. This is obviously a greedy strategy and it does not guarantee that the total travel distance of all taxis for all queries is minimized. &lt;u&gt;Howerver, the problem of optimizing travel distance for all taxis for the whole query stream has been proved to be NP-complete by reducing to the Travelling Salesman Problem with Time Window.&lt;/u&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33-framework&#34;&gt;3.3. Framework&lt;/h3&gt;





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/framework_hu80a8d6d7f84148f102c61f3aba0566fb_75147_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/framework_hu80a8d6d7f84148f102c61f3aba0566fb_75147_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;513&#34; height=&#34;459&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;4-method&#34;&gt;4. Method&lt;/h2&gt;
&lt;h3 id=&#34;41-a-spatio-temporal-index-of-taxis&#34;&gt;4.1. A Spatio-temporal Index of Taxis&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : It needs to use the query’s time windows to filter out unsatisfactory taxis. The authors want a taxi searching process that is both fast and selects taxis wisely such that the selected taxis can satisfy the query with a reasonable small increase in travel distance over their existing schedules. If we use a pre-computed distance to approximate the distance of the shortest path, though the distance is not exact anymore, the time-consuming problem completely goes away.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We partition the road network using a grid. Within each grid cell, we choose the road network node which is closest to the geographical centre of the cell as the anchor node of the cell. The anchor node of a grid cell $g_{i}$ is thereafter denoted by $c_{i}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_1_huf29fbc3cd8f55bc41b1972a0aa4ee356_31851_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_1_huf29fbc3cd8f55bc41b1972a0aa4ee356_31851_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;321&#34; height=&#34;312&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We pre-compute the distance, denoted by $d_{ij}$ , and travel time, denoted by $t_{ij}$ , of the shortest path on the road network for each anchor node pair $c_{i}$ and $c_{j}$ . The distance and travel time results are saved in a matrix. The matrix is thereafter referred to as the grid distance matrix.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_2_huc544431513aa519ce59bb06262b6fd41_25966_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_2_huc544431513aa519ce59bb06262b6fd41_25966_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;366&#34; height=&#34;315&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Now imagine that each grid cell collapses to its anchor node, that is, all the points in one cell fall to its anchor node. Then the distance between any two arbitrary points equals to the distance between two corresponding anchor nodes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each cell has some internal data structure for the purpose of taxi searching. Specifically, each grid cell $g_{i}$ maintains three lists: a temporally-ordered grid cell list $(g_{i}.l_{g}^{t})$ , a spatially-ordered grid cell list $(g_{i}.l_{g}^{d})$ , and a taxi list $(g_{i}.l_{v})$ . The spatial and temporal closeness between each pair of grid cells are measured by the values saved in the grid distance matrix.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_1_3_hu2d038ac018bc8d992497e2484a0723fd_26837_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_1_3_hu2d038ac018bc8d992497e2484a0723fd_26837_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;520&#34; height=&#34;299&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Each taxi ID is also tagged with a timestamp $t_{a}$ indicating when the taxi will enter the grid cell. Specifically, taxi $V_{j}$ is removed from the list when $V_{j}$ leaves $g_{i}$ ; taxi $V_{k}$ is inserted into the list when $V_{j}$ is newly scheduled to enter $g_{i}$ .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-taxi-searching-algorithms&#34;&gt;4.2. Taxi Searching Algorithms&lt;/h3&gt;
&lt;h4 id=&#34;421-single-side-taxi-searching&#34;&gt;4.2.1. Single-side Taxi Searching&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : We use query&amp;rsquo;s late pick-up timestamp to filter out grids, then filter the possible taxis from the candidate grids.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Suppose a passenger commits a query $Q$ located at grid $g_{7}$ at the time of $t_{cur}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_1_hu7d7e326b5cd973f956622b15ceb057ed_98800_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_1_hu7d7e326b5cd973f956622b15ceb057ed_98800_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;638&#34; height=&#34;387&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Any other arbitrary grid cell is selected by the searching algorithm if and only if
$$t_{i7} + t_{cur} \leq Q.wp.l$$
$t_{i7}$ indicates the travel time from grid $g_{i}$ to grid $g_{7}$ . To quickly find all grids hold the equation above, the single-side searching algorithm simply tests all grid cells in the order-preserved list $g_{7}.l_{g}^{t}$ and finds the first grid $g_{f}$ fails to hold the equation. Then the grids before $g_{f}$  in the list $g_{7}.l_{g}^{t}$ are selected as candidate taxis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For  each selected grid cell $g_{s}$ , the algorithm selects taxis (in $g_{s}.l_{v}$) whose $t_{a}$ is no later than $Q.wp.l - t_{s7}$ .





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_2_hub75161ce21867257f31b85020308e40b_30416_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_2_hub75161ce21867257f31b85020308e40b_30416_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;589&#34; height=&#34;249&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Weakness&lt;/strong&gt; : Unfortunately, this algorithm only considers taxis currently &amp;ldquo;near&amp;rdquo; the pickup point of a query (thus called single-side search). As the number of selected grid cells could be large, this algorithm may result in many taxis retrieved for the later scheduling module (therefore increasing the entire computation cost).&lt;/p&gt;
&lt;h4 id=&#34;422-dual-side-taxi-searching&#34;&gt;4.2.2. Dual-Side Taxi Searching&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : The spatio-temporal factor on the delivery point of queries also provides us with opportunities to reduce the number of grid cells to be selected. A dual-side searching algorithm is proposed as an effort for striking a balance between the distance optimality and the computation cost.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Suppose the deliver point is at grid $g_{2}$ . Any grid cell $g_{j}$ other than $g_{2}$ is selected by the searching algorithm at side if and only if the equation below holds, which means that any taxi currently in can enter before the late bound of the delivery window.
$$t_{cur}+t_{j2} \leq Q.wd.l$$





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_3_hu31892b81786e77bcee49283119a63262_101906_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_3_hu31892b81786e77bcee49283119a63262_101906_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;665&#34; height=&#34;376&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The algorithm mantains a set $S_{o}$ and a set $S_{d}$ to store the taxis selected from $Q.o$ and $Q.d$ side respectively.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Initially, both and are empty.&lt;/li&gt;
&lt;li&gt;The first step in the searching is to add the taxis selected from taxi list $g_{7}.l_{v}$ to set $S_{o}$ , and add the taxis selected from taxi list $g_{2}.l_{v}$ to set $S_{d}$ . Then the algorithm calculates the intersection of $S_{o}$ and $S_{d}$ .&lt;/li&gt;
&lt;li&gt;If the intersection is not empty, the algorithm stops immediately and returns the intersection set. Otherwise, it expands the searching area by including one other grid cell at each side at a time.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_2_4_hua22a83df82277672b1b2b72fdfd73af6_110070_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_2_4_hua22a83df82277672b1b2b72fdfd73af6_110070_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;640&#34; height=&#34;625&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-scheduling-module&#34;&gt;4.3. Scheduling Module&lt;/h3&gt;
&lt;h4 id=&#34;431-insertion-feasibility-check&#34;&gt;4.3.1. Insertion Feasibility Check&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The insertion can be separated into two stages: (i) insert the pickup point of the query $Q.o$ ; (ii) insert the delivery point of the query $Q.d$ . Among all possible ways of insertion, the system chooses the insertion way that minimally increases the travel distance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An insertion feasibility check is done before an insertion:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The passenger should be picked up before $Q.wp.l$ .&lt;/li&gt;
&lt;li&gt;Travel time delay $t_{d}$ should not result the late arrival at any point after the insertion.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The increased travel distance is calculated when both $Q.o$ and $Q.d$ are inserted successfully.





  
  











&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/2020-2-4-1/method_3_1_hu943817b818205cb3f2c05fa79d2c2b07_37963_2000x2000_fit_lanczos_2.png&#34; &gt;


  &lt;img data-src=&#34;/post/2020-2-4-1/method_3_1_hu943817b818205cb3f2c05fa79d2c2b07_37963_2000x2000_fit_lanczos_2.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;672&#34; height=&#34;186&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;432-lazy-shortest-path-calculation-strategy&#34;&gt;4.3.2. Lazy Shortest Path Calculation Strategy&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Main Idea&lt;/strong&gt; : The paper aims to expedite the insertion process by speeding up the calculation itself instead of eliminating some insertion possibilities.&lt;/p&gt;
&lt;p&gt;The calculation of shortest path is deferred or avoided by the following logic:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the shortest path between the origin location O and the destination location D has been previously calculated, then the algorithm simply retrieves the path from the cached results.&lt;/li&gt;
&lt;li&gt;Otherwise, instead of directly calculating the shortest path, the algorithm first calculates the lower bound of the travel time between O and D using the precomputed travel time between grid cells and the triangle inequality. Only when the lower bound does not violate time constraints, the algorithm needs to proceed to compute the shortest-time path between points O and D.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It is evident that the grid size will affect the effectiveness of lazy shortest path calculation strategy. State-of-art shortest path algorithms can be applied to speed up on-line shortest path calculations.&lt;/p&gt;
&lt;h3 id=&#34;5-experiment&#34;&gt;5. Experiment&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Measurements
&lt;ol&gt;
&lt;li&gt;Relative Distance Rate (RDR) : Define the distance of a query $Q$ as the distance between its pickup point $Q.o$ and its delivery point $Q.d$ . Denote by $D_{SQ}$ the sum of distances of queries that get satisfied and by $D_{V}$ the total distance travelled by all taxis in the ridesharing.
$$RDR = D_{V}/D_{SQ}$$&lt;/li&gt;
&lt;li&gt;Satisfaction Rate (SR) : is the fraction of queries get satisfied in the ridesharing (exclude queries that are already served by taxis at the initial state in the query counting).&lt;/li&gt;
&lt;li&gt;Number of Road Nodes Accessed Per Query (#RNAPQ) : is the number of accessed road network nodes per query.&lt;/li&gt;
&lt;li&gt;Number of Grid Cells Accessed Per Query (#GCAPQ) : is the number of accessed grid cells per query.&lt;/li&gt;
&lt;li&gt;Number of Taxis Accessed Per Query (#TAPQ) : This measurement records how many taxis per query are accessed for insertion feasibility checks by the scheduling module.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
